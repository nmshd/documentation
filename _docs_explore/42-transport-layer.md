---
title: "Transport Layer"
permalink: /explore/layers/transport
toc: true
---

The transport layer is between the backbone layer and the consumption layer. Thus it is located between the trusted environment (own device/network) and the untrusted environment (Backbone). It is usually hosted as a REST API by the Connector or programmatically accessed by the App. The runtime is the primary technical building block, containing the transport library, the content library and the crypto library.

All encryption-relevant topics like key handling and signature verification are encapsulated by the transport layer. The requests to and responses from the transport layer are thus all plaintext.

# Identity

The identity semantically is the "digital twin" of the actual real-world person or organization.

Technically, the identity primarily consists of one keypair. By signing with the identity's private key, one is able to prove the ownership of the identity and thus manage the identity completely. Based on the identity's public key, the primary identification property, the address is created.

One has to keep in mind that Enmeshed doesn't enforce the validation of the real-world entities. Thus one real-world entity could create fake identities.

Additionally, Enmeshed cannot enforce a uniqueness of real-world entities, i.e. one real-world entity could create multiple Enmeshed identities for itself.

## Identity Keys

### Identity Signature Private Key

Abbreviated: PrivId

The identity's most secret, private signature key with which it is signing certificates, documents or the creation of new devices.

### Identity Signature Public Key

Abbreviated: PubId

The identity's public key which acts as the primary form of verifying data signed by an identity. Only with a known Identity Signature Public Key of an identity, the signature of an identity can be securely verified.

With the identity's public key, the identity's address is calculated.

Usually, you receive another identity's signature public key while making the first contact (e.g. from the relationship template or the relationship request followed upon it).

### Synchronization Derived Secret Key

The symmetric keys which are derived from the synchronization master key and are used to actually encrypt/decrypt the synchronization events.

### Synchronization Master Secret Key

The symmetric master key which is used to derive the synchronization derived secret keys. The synchronization master secret key is randomly generated on creation for every identity.

## Address

The identity's address is the primary way to identify an identity. It is a calculated property based on the identity's public key and thus cannot be changed for an identity.

# Devices

## Device Structure

-   id
-   publicKey (optional)
-   certificate (optional)
-   name
-   description (optional)
-   createdAt
-   createdByDevice
-   operatingSystem (optional)
-   lastLoginAt (optional)
-   type
-   username

## Device Synchronization

Devices are usually kept in synchronization with each other over a synchronization service.

## Device Onboarding Info

-   id
-   createdAt
-   createdByDevice
-   name (optional)
-   description (optional)
-   secretBaseKey
-   deviceIndex
-   synchronizationKey
-   identityPrivateKey (optional)
-   identity
-   password
-   username

## Device Keys

# Files

Abbreviated: FIL

A file is an Enmeshed representation of any binary-large object (BLOB). Handling files is similar to handling tokens, the big difference is, that tokens provide a means to share structured content whereas files are uploaded to and downloaded from the backbone by the help of binary transfer methods.

The actual file is then shared by a file reference to a recipient. Files can be short-lived or long-lived, depending on the business case - use the expiresAt property to define the expiry of a file.

## File Structure

-   id: Random file id generated by the backbone once the upload was finished
-   title: Human readable file title
-   description: Description of the file
-   filename: Filename of the original file (used for storing the file on local systems)
-   filesize: Plaintext size of the original file's payload
-   createdAt: ISO String when the file has been created
-   createdBy: Address of the identity which created the file
-   createdByDevice: Device id of the device which created the file
-   expiresAt: ISO String when the file expires
-   mimetype: Mimetype of the file's payload
-   isOwn: Whether or not the file was uploaded by the current identity
-   deletedAt: ISO String when the file has been deleted
-   deletedBy: Address of the identity which deleted the file
-   deletedByDevice: Device id of the device which deleted the file

## File Encryption

As with tokens, prior to the upload, a random secret key is generated and used to encrypt the file payload. In addition to the file payload, metadata (like filename or mimetype) to the file is stored next to it. For this, another random secret key is generated for encrypting the metadata. To omit unnecessary payload while sharing files, the generated secret key for actual file payload is encrypted with its metadata, so that only the generated secret key for the metadata must be shared (in addition to the file id).

## File Reference

The file id and the generated metadata secret key are the only two properties which need to be submitted to another user. Both properties are usually sent within a message to the recipients.

# Messages

Abbreviated: MSG

A message is any kind of structured content which should be securely transmitted to relationships. Messages can be submitted to multiple recipients and can deliver multiple attachments (in form of file references).
Depending on the content of the message, a message could act as a technical message (e.g. a multi-factor authentication request) which shouldn't be rendered.

## Message Structure

-   id: random message id generated by the backbone once the message has been created
-   createdAt: ISO String when the message has been created
-   createdBy: Address of the identity which created the message
-   createdByDevice: Device id of the device which created the message
-   recipients: Array of recipients
    -   address: Address of one of the identity which should receive the message
    -   receivedAt: ISO String when the recipient received the message
    -   receivedByDevice: Device id of the recipient's device which received the message
-   relationshipIds: Array of relationship ids of the recipients (same order as recipients)
-   content: The content of the message
-   attachments: Array of files which are attached to this message

# Relationships

The link between two identities is called relationship. From the view of one identity or its device, the "own" keyword decribes content created by its own. The "peer" keyword describes content of the other party.

Relationships are usually used as the technical term, whereas contact is used as a business terminology. To be more strict, one could say that contacts are active relationships, as a relationship could also be terminated (thus a communication would no longer be possible).

## Relationship Structure

-   id
-   template
-   status
-   peer
-   changes
    -   id
    -   type
    -   status
    -   request
        -   createdBy
        -   createdByDevice
        -   createdAt
        -   content
    -   response
        -   createdBy
        -   createdByDevice
        -   createdAt
        -   content
-   lastMessageSentAt
-   lastMessageReceivedAt

## Relationship Keys

With each relationship, there are relationship keys automatically generated. These keys are used for signing and encrypting the communication with the relationship on a technical level.

-   Relationship own exchange keypair: A pair of relationship own exchange private key (PrivOwnX) and corresponding relationship own exchange public key (PubOwnX). The relationship own exchange private key is used to derive the masterRelationship secret keys (transmit and receive). The relationship's own exchange public key is communicated within the relationship request or the relationship creation change response.
-   Relationship own signature keypair: A pair of relationship signature private key (PrivOwn) and corresponding relationship signature public key (PubOwn). The signature own private key is used for signing the communication with this relationship. It is synchronized across all devices and signed by the device signature private key of the device which creates the relationship response to it, or the relationship template. The signature own public key is used for verifying the signatures of all communications with this relationship.
-   Relationship peer exchange public key: The peer's exchange public key (PubPeerX) which is used to derive the master relationship secret keys (transmit and receive).
-   Relationship peer signature public key: The peer's signature public key which is used to verify communication sent by the peer.
-   Relationship receive derived secret key (SecPeer'): A derived symmetric key of the master, which is actually used for decryption.
-   Relationship receive master secret key (SecPeer):
    The symmetric master key for receiving communication of the relationship. The key is derived by the relationship peer exchange public key and the relationship own exchange private key while onboarding. This key equals to the relationship transmit master key of the peer.
-   Relationship transmit derived secret key (SecOwn'): A derived symmetric key of the master, which is actually used for encryption.
-   Relationship transmit master secret key (SecOwn):
    The derived symmetric master key for transmitting communication to the relationship. The key is derived by the relationship peer exchange public key and the relationship own exchange private key. This key equals to the relationship receive master key of the peer.

## Relationship Changes

Relationships are agreements between two identities. Thus, to change a relationship both parties have to accept on the new "terms". This is done by requesting a change which the other party can accept or reject. The requestor could also revoke a requested change, as long as the other party did not react to the change yet.

The very first agreement between both parties is to actually create the relationship, the "relationship creation change". It was also called "relationship request" in the past.

### Relationship Creation Change Requests

The relationship creation change requests (short: Relationship Requests) - next to the required technical information - usually contain:

-   Requested information from the requestor
    -   Required/optional attributes
    -   Certificates
    -   Signatures
    -   Answers to questionnaire
-   Websession information
-   OK to privacy statement
-   OK to EULA

# Relationship Templates

A relationship template is a structured representation of data which is required for a relationship to be established. Thus, it is usually also addressing the required information for a business process to start.
In addition to technical information like public keys, certificates or signatures, it usually contains:

-   Information which the templator would like to share about itself
    -   Templator attributes (e.g. company name, address, phone numbers)
    -   Contact details
-   Private information which the templator would like to share about the requestor
    -   Requestor attributes
    -   Websession information
-   Requested additional information about the requestor
    -   Required/optional attributes
    -   Certificates
    -   Signatures
    -   Questionnaires
-   Meta information
    -   Data privacy guidelines
    -   EULAs

A relationship template needs to be created in order to receive relationship requests and ultimately create an active relationship between two identities. The relationship template is then usually shared with the user via a token.

Relationship templates can be both: identity-specific (template is personalized for one specific identity - which might not exist yet) or identity-agnostic (template is open for multiple identities).

## Identity-specific Templates

## Identity-agnostic Templates

## Relationship Template Structure

-   id
-   maxNumberOfRelationships
-   isOwn
-   createdBy
-   createdByDevice
-   createdAt
-   expiresAt
-   content

# Tokens

Commonly used data-sharing possibilities like links (URIs) or QR codes are limited in size. Thus, even compressed representations of - e.g. relationship templates - are too big to be stored in a QR code. In addition, the data which is shared usually should expire after a certain period in time. For example, a personalized relationship template containing sensitive data should be deleted after 5 minutes.

To overcome these technical limitations, an indirection with a shared token is introduced. The token acts as a small data-reference object: The actual to-be-shared data is encrypted with a random key and the corresponding cipher is stored on the central platform with additional information like an expiry date.

Tokens can be accessed by everyone (having a correct token id and the respective token secret key). Tokens are usually short lived content, however the expiry of tokens can be set to any date.

## Token References

The token id and the generated secret key are then the only two properties which need to be submitted to another user. Both properties are usually encoded into a base64url-encoded format which is called token reference. This token reference is usually transfered to another user in the shape of a link or a QR code.

## Token Structure

-   id
-   createdBy
-   createdByDevice
-   createdAt
-   expiresAt
-   content
-   secretKey
-   truncatedReference
