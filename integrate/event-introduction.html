<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Event introduction - enmeshed</title>
<meta name="description" content="Connecting an external system with the enmeshed Connector, the main communication is performed by addressing the Connector’s REST API. This way, processes can be initiated by the organization’s backend service or data can be requested from the Connector. In addition, events offer the possibility for the Connector to actively give feedback to the external system. Thus, a bidirectional communication is established.    What is an event?  Events are predefined datastructures used within enmeshed to communicate a significant change of an entity’s state. They are heavily used internally by the enmeshed Runtime, but can also be propagated by the Connector to external systems. Thus, these systems don’t have to perform long polling, in order to receive changes, but are actively informed once they occur. This is not only more efficient, also, its is safer, since it keeps you updated about all changes of interest. Working with events allows to determine routines, that are executed whenever a specific event arises, called handlers. An overview of the Connector events that may occur is given in the corresponding section.  Motivation for using events  As an exemplary process of how working with events can benefit your mode of operation, we look at the procedure of exchanging Messages.  Procedure without events  Firstly, we consider the case without using events. To send a Message, the external system posts the corresponding request to the REST API of the Connector. Then, it regularly fetches its state, until a response is received. This might take many cycles, depending on the refresh rate, and implies a delay between the time the response is received by the Connector and the external system.    Procedure with events  In contrast, if you work with events, as soon as the Connector successfully sent your Message, a transport.messageSent event will be transmitted to your system as a confirmation. Awaiting the response, no long polling is necessary, since the Connector actively sends a transport.messageReceived event, containing the answer, once it is received.    Modules to receive events  In order to receive events, the Connector needs to be synchronized with the Backbone. This can be automated using the Sync Module. Fetching changes from the Backbone regularly, it forwards the received events to Modules that are configured to process them, e.g. AMQP Publisher, PubSub Publisher or Webhooks. Working with message brokers has the advantage that events are conserved, even in case of a downtime of the recipient. Thus, we recommend to work with a message broker module like AMQP or PubSub instead of Webhooks.">


  <meta name="author" content="Enmeshed Team">
  
  <meta property="article:author" content="Enmeshed Team">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="enmeshed">
<meta property="og:title" content="Event introduction">
<meta property="og:url" content="/integrate/event-introduction">


  <meta property="og:description" content="Connecting an external system with the enmeshed Connector, the main communication is performed by addressing the Connector’s REST API. This way, processes can be initiated by the organization’s backend service or data can be requested from the Connector. In addition, events offer the possibility for the Connector to actively give feedback to the external system. Thus, a bidirectional communication is established.    What is an event?  Events are predefined datastructures used within enmeshed to communicate a significant change of an entity’s state. They are heavily used internally by the enmeshed Runtime, but can also be propagated by the Connector to external systems. Thus, these systems don’t have to perform long polling, in order to receive changes, but are actively informed once they occur. This is not only more efficient, also, its is safer, since it keeps you updated about all changes of interest. Working with events allows to determine routines, that are executed whenever a specific event arises, called handlers. An overview of the Connector events that may occur is given in the corresponding section.  Motivation for using events  As an exemplary process of how working with events can benefit your mode of operation, we look at the procedure of exchanging Messages.  Procedure without events  Firstly, we consider the case without using events. To send a Message, the external system posts the corresponding request to the REST API of the Connector. Then, it regularly fetches its state, until a response is received. This might take many cycles, depending on the refresh rate, and implies a delay between the time the response is received by the Connector and the external system.    Procedure with events  In contrast, if you work with events, as soon as the Connector successfully sent your Message, a transport.messageSent event will be transmitted to your system as a confirmation. Awaiting the response, no long polling is necessary, since the Connector actively sends a transport.messageReceived event, containing the answer, once it is received.    Modules to receive events  In order to receive events, the Connector needs to be synchronized with the Backbone. This can be automated using the Sync Module. Fetching changes from the Backbone regularly, it forwards the received events to Modules that are configured to process them, e.g. AMQP Publisher, PubSub Publisher or Webhooks. Working with message brokers has the advantage that events are conserved, even in case of a downtime of the recipient. Thus, we recommend to work with a message broker module like AMQP or PubSub instead of Webhooks.">







  <meta property="article:published_time" content="2024-02-02T18:15:48+01:00">






<link rel="canonical" href="/integrate/event-introduction">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="enmeshed Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <link href="/assets/css/overwrite.css" rel="stylesheet" type="text/css" />

<!-- The following lines are needed because otherwise Prism (the syntax highlighter RapiDoc uses) breaks Rouge (the syntax highlighter we use) -->
<script>
    window.Prism = window.Prism || {};
    Prism.manual = true;
</script>
<script type="module" src="https://unpkg.com/rapidoc/dist/rapidoc-min.js"></script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          enmeshed
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/use">Use</a>
            </li><li class="masthead__menu-item">
              <a href="/explore">Explore</a>
            </li><li class="masthead__menu-item">
              <a href="/integrate">Integrate</a>
            </li><li class="masthead__menu-item">
              <a href="/operate">Operate</a>
            </li><li class="masthead__menu-item">
              <a href="/contribute">Contribute</a>
            </li><li class="masthead__menu-item">
              <a href="/blog">Blog</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      <h3>Integrate enmeshed</h3>
      
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Getting Started</span>
        

        
        <ul>
          
            <li><a href="/integrate/access-the-connector">Access the Connector</a></li>
          
            <li><a href="/integrate/integration-example">Integration example</a></li>
          
            <li><a href="/integrate/event-introduction" class="active">Event introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Working with requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/request-and-response-introduction">Request and Response introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage Requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/requests-over-templates">Requests over Templates</a></li>
          
            <li><a href="/integrate/requests-over-messages">Requests over Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of yourself</span>
        

        
        <ul>
          
            <li><a href="/integrate/share-own-attribute-to-peer">Share own Attribute to peer</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of others</span>
        

        
        <ul>
          
            <li><a href="/integrate/read-attribute-from-peer">Read Attribute from peer</a></li>
          
            <li><a href="/integrate/create-attribute-for-peer">Create Attribute for peer</a></li>
          
            <li><a href="/integrate/propose-attribute-to-peer">Propose Attribute to peer</a></li>
          
            <li><a href="/integrate/request-persistent-consent-of-peer">Request persistent consent of peer</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Basic communication</span>
        

        
        <ul>
          
            <li><a href="/integrate/sending-messages">Sending Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Requesting consent of users</span>
        

        
        <ul>
          
            <li><a href="/integrate/requesting-one-time-consents">Requesting one-time consents</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Data Model</span>
        

        
        <ul>
          
            <li><a href="/integrate/use-cases">Use Cases</a></li>
          
            <li><a href="/integrate/data-model-overview">Data Model Overview</a></li>
          
            <li><a href="/integrate/connector-events">Connector Events</a></li>
          
            <li><a href="/integrate/requests-and-requestitems">Requests and RequestItems</a></li>
          
            <li><a href="/integrate/attribute-values">Attribute Values</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Troubleshooting</span>
        

        
        <ul>
          
            <li><a href="/integrate/error-codes">Error Codes</a></li>
          
            <li><a href="/integrate/faq">FAQ</a></li>
          
            <li><a href="/integrate/support">Support</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Event introduction">
    <meta itemprop="description" content="Connecting an external system with the enmeshed Connector, the main communication is performed by addressing the Connector’s REST API.This way, processes can be initiated by the organization’s backend service or data can be requested from the Connector.In addition, events offer the possibility for the Connector to actively give feedback to the external system.Thus, a bidirectional communication is established.What is an event?Events are predefined datastructures used within enmeshed to communicate a significant change of an entity’s state.They are heavily used internally by the enmeshed Runtime, but can also be propagated by the Connector to external systems.Thus, these systems don’t have to perform long polling, in order to receive changes, but are actively informed once they occur.This is not only more efficient, also, its is safer, since it keeps you updated about all changes of interest.Working with events allows to determine routines, that are executed whenever a specific event arises, called handlers.An overview of the Connector events that may occur is given in the corresponding section.Motivation for using eventsAs an exemplary process of how working with events can benefit your mode of operation, we look at the procedure of exchanging Messages.Procedure without eventsFirstly, we consider the case without using events.To send a Message, the external system posts the corresponding request to the REST API of the Connector.Then, it regularly fetches its state, until a response is received.This might take many cycles, depending on the refresh rate, and implies a delay between the time the response is received by the Connector and the external system.Procedure with eventsIn contrast, if you work with events, as soon as the Connector successfully sent your Message, a transport.messageSent event will be transmitted to your system as a confirmation.Awaiting the response, no long polling is necessary, since the Connector actively sends a transport.messageReceived event, containing the answer, once it is received.Modules to receive eventsIn order to receive events, the Connector needs to be synchronized with the Backbone.This can be automated using the Sync Module.Fetching changes from the Backbone regularly, it forwards the received events to Modules that are configured to process them, e.g. AMQP Publisher, PubSub Publisher or Webhooks.Working with message brokers has the advantage that events are conserved, even in case of a downtime of the recipient.Thus, we recommend to work with a message broker module like AMQP or PubSub instead of Webhooks.">
    <meta itemprop="datePublished" content="2024-02-02T18:15:48+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="/integrate/event-introduction" class="u-url" itemprop="url">Event introduction
</a>
          </h1>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#what-is-an-event">What is an event?</a></li><li><a href="#motivation-for-using-events">Motivation for using events</a><ul><li><a href="#procedure-without-events">Procedure without events</a></li><li><a href="#procedure-with-events">Procedure with events</a></li></ul></li><li><a href="#modules-to-receive-events">Modules to receive events</a></li></ul>

            </nav>
          </aside>
        
        <p>Connecting an external system with the <a href="/explore/how_does_enmeshed_work#enmeshed-connector">enmeshed Connector</a>, the main communication is performed by addressing the Connector’s REST API.
This way, processes can be initiated by the organization’s backend service or data can be requested from the Connector.
In addition, events offer the possibility for the Connector to actively give feedback to the external system.
Thus, a bidirectional communication is established.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/9940dd19-73bc-4afc-acf2-72d5d47747ed" id="OvvNQKWFWkgc"></iframe></div>

<h2 id="what-is-an-event">What is an event?</h2>

<p>Events are predefined datastructures used within enmeshed to communicate a significant change of an entity’s state.
They are heavily used internally by the enmeshed Runtime, but can also be propagated by the Connector to external systems.
Thus, these systems don’t have to perform long polling, in order to receive changes, but are actively informed once they occur.
This is not only more efficient, also, its is safer, since it keeps you updated about all changes of interest.
Working with events allows to determine routines, that are executed whenever a specific event arises, called handlers.
An overview of the <a href="/integrate/connector-events">Connector events</a> that may occur is given in the corresponding section.</p>

<h2 id="motivation-for-using-events">Motivation for using events</h2>

<p>As an exemplary process of how working with events can benefit your mode of operation, we look at the procedure of exchanging <code class="language-plaintext highlighter-rouge">Messages</code>.</p>

<h3 id="procedure-without-events">Procedure without events</h3>

<p>Firstly, we consider the case without using events.
To send a <code class="language-plaintext highlighter-rouge">Message</code>, the external system posts the corresponding request to the REST API of the Connector.
Then, it regularly fetches its state, until a response is received.
This might take many cycles, depending on the refresh rate, and implies a delay between the time the response is received by the Connector and the external system.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/e4d12a4d-faf5-4133-9ea2-c69a716b1975" id="8vvNLAyZJbL9"></iframe></div>

<h3 id="procedure-with-events">Procedure with events</h3>

<p>In contrast, if you work with events, as soon as the Connector successfully sent your <code class="language-plaintext highlighter-rouge">Message</code>, a <code class="language-plaintext highlighter-rouge">transport.messageSent</code> event will be transmitted to your system as a confirmation.
Awaiting the response, no long polling is necessary, since the Connector actively sends a <code class="language-plaintext highlighter-rouge">transport.messageReceived</code> event, containing the answer, once it is received.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/c1e9f677-1e81-4787-9718-4f94f6a16727" id="3wvNo3dv6Zqo"></iframe></div>

<h2 id="modules-to-receive-events">Modules to receive events</h2>

<p>In order to receive events, the Connector needs to be synchronized with the Backbone.
This can be automated using the <a href="/operate/modules#sync">Sync Module</a>.
Fetching changes from the Backbone regularly, it forwards the received events to <a href="/operate/modules">Modules</a> that are configured to process them, e.g. <a href="/operate/modules#amqppublisher">AMQP Publisher</a>, <a href="/operate/modules#pubsubpublisher">PubSub Publisher</a> or <a href="/operate/modules#webhooksv2">Webhooks</a>.
Working with message brokers has the advantage that events are conserved, even in case of a downtime of the recipient.
Thus, we recommend to work with a message broker module like AMQP or PubSub instead of Webhooks.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/d077ee93-9025-43d6-833e-5ee2f1d966d5" id="bnvNknrH-TUP"></iframe></div>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2024-02-02T18:15:48+01:00">February 2, 2024</time></p>

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
           
        <li>
            <a href="/legal" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-info" aria-hidden="true"></i> Legal Disclosure</a>
        </li>
          
        <li>
            <a href="/privacy" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-user-shield" aria-hidden="true"></i> Privacy Statement</a>
        </li>
          
        <li>
            <a href="https://www.enmeshed.eu" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Website</a>
        </li>
          
        <li>
            <a href="https://github.com/nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a>
        </li>
          
        <li>
            <a href="https://www.npmjs.com/search?q=%40nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-npm" aria-hidden="true"></i> NPM</a>
        </li>
           
        <li>
            <a href="/feed.xml"
                ><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a
            >
        </li>
        
    </ul>
</div>

<div class="page__footer-copyright">
    &copy; 2024
    <a href="https://www.js-soft.com">j&amp;s-soft GmbH</a>. Powered by
    <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
