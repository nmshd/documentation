<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Request and Response introduction - enmeshed</title>
<meta name="description" content="Requests are the main instrument in enmeshed to interact with other Identities. They enable various business processes, e.g. creating, sharing or receiving Attributes, asking a peer for authentication or consent, and much more. Also, parts of a vaster business process can be implemented with them, like querying all personal information of a user to fill out a tax form.  Requests are unique between Identities and can only be processed once by a single Identity, even across multiple devices associated with them. Each Request can only have a single Response, which responds to the complete Request and contains all the information the requestor needs. The Request-Response flow allows to establish transactional behavior between Identities.  Please note that there are some data structures used in the context of enmeshed, that also use the terms “Request” and “Response” in their name, but do not correspond to the objects described on this page, e.g. RelationshipChangeRequest and RelationshipChangeResponse.  Requests    Structure of Requests  A Request can be created by an Identity and sent to a peer to exchange information with them. Specifying the exact demands to the peer, RequestItems are the core of the Request. In case multiple RequestItems should be answered jointly, e.g. to enhance the structure for the user, they can be combined to a RequestItemGroup. After creating the Request, it can be transmitted either via a Template (see Requests over Templates) or via a Message (see Requests over Messages).  Types of RequestItems  To extinguish different scenarios how to use Requests, there are various types of RequestItems tailored to them.  AuthenticationRequestItem  With the AuthenticationRequestItem the sender can request the peer for an authentication in a business context for a certain purpose. The peer can then decide to authenticate or not. This authentication is mostly short-lived and limited in time.  Examples:     Authentication for a login to a website   Authentication for opening a door   ConsentRequestItem  With the ConsentRequestItem it is possible to request a consent of the peer to an arbitrary text and thus reach agreement on a certain non machine-processable context.  To request an accept/reject decision from a peer to a free text, the ConsentRequestItem is used.  Please do not use the ConsentRequestItem to submit tons of text to the peer Identity. It is meant to be a short consent or summary the user agrees to. Please move longer text to external websites. The ConsentRequestItem is also not meant for contractual agreements.  Examples:     “I hereby confirm that I have read the privacy terms of this cloud service and agree to them.”   “The provided EULA has been read and agreed to.”   “Yes, I have backed up all of my data of this PC and you can wipe it.”   “I opt in to the newsletter.”   CreateAttributeRequestItem  If you want to create Identity- or RelationshipAttributes for the peer, the CreateAttributeRequestItem can be used. Please have a look at the ProposeAttributeRequestItem if the peer should be able to overwrite the Attribute.  To create an Attribute with a fixed value defined by the sender, an Identity uses the CreateAttributeRequestItem. A fixed value in this case means, that the recipient is not allowed to change the value when accepting the request.  Examples of use cases for the CreateAttributeRequestItem can be found in the Create Attribute for peer guide.  FreeTextRequestItem  With the FreeTextRequestItem it is possible to send a free text to the peer. The peer itself can accept this with a free text as well.  ProposeAttributeRequestItem  The ProposeAttributeRequestItem is a combination of ReadAttributeRequestItem and CreateAttributeRequestItem. The sender would like to receive a correct Attribute from the peer, thinks it has a possible value but the peer might overrule this value with an existing or new one.  To create an Attribute with a value proposed by the sender, an Identity uses the ProposeAttributeRequestItem. A proposed value in this case means, that the recipient is allowed to change the value if accepting the request.  Examples of use cases for the ProposeAttributeRequestItem can be found in the Propose Attribute to peer guide.  ReadAttributeRequestItem  If you want to query an Identity’s Attributes this is done with the ReadAttributeRequestItem.  To query Attributes which are not known to the sender, an Identity uses the ReadAttributeRequestItem.  Examples of use cases for the ReadAttributeRequestItem can be found in the Read Attribute from peer guide.  RegisterAttributeListenerRequestItem  This item is used to register a Listener for a specific Attribute. The Listener will create a Request in status Draft if an Attribute was created that matches the given query and the user is able to send the Request to the creator of the RegisterAttributeListenerRequestItem.  Examples:     Asking for a specific RelationshipAttribute of a partner organization.   ShareAttributeRequestItem  If you want to share the own DisplayName and possibly other Attributes this is done with the ShareAttributeRequestItem.  To share own IdentityAttributes (owner = self) an Identity uses the ShareAttributeRequestItem. The Identity needs to create the IdentityAttribute separately before the Attribute can be shared.  Examples of use cases for the ShareAttributeRequestItem can be found in the Share own Attribute to peer guide.  Responses    Structure of Responses  Once the other Identity receives a Request, they can decide whether to accept or reject it. Then, a Response will be created, containing a ResponseItem or ResponseItemGroup for every RequestItem or RequestItemGroup, respectively. The kind of ResponseItem depends on the decision of the Recipient, as well as on the kind of RequestItem.  Types of ResponseItems  There are three different categories of ResponseItems. If a RequestItem is accepted, an AcceptResponseItem will be created. Depending on the kind of RequestItem, it might be a specific AcceptResponseItem, extending the base AcceptResponseItem to answer to RequestItems demanding additional information. For example, a ReadAttributeRequestItem is accepted using a ReadAttributeAcceptResponseItem, additionally transmitting information about the respective Attribute.    If a RequestItem is rejected, however, a RejectResponseItem is created. Lastly, in case the enmeshed Runtime detects a problem, an ErrorResponseItem is generated. It will never be created manually.  Request-Response flow  LocalRequests and LocalResponses  Requests and Responses as discussed above refer to the data structures that are exchanged between Identities. Locally, each Identity stores them in LocalRequests and LocalResponses. Note that the LocalResponse is stored within the respective LocalRequest, besides properties that are common for both peers like the LocalRequestStatus and others that are distinct for each Identity, e.g. the address of the peer or whether the Request was sent by you or received from the peer.  Sending Requests via Messages  Requests can only be send via Message, if you already have an active Relationship with the recipient. Otherwise, you need to utilize a RelationshipTemplate.  If you want to send a Request via Message, firstly you need to create a LocalRequest. Its ID equals the one of the associated Request that is sent in a Message to your peer. If the peer accepts the Request and reponds to it, at their side a LocalRequest will be created, having the same ID, however, opposite values for the fields peer and isOwn. Also, a LocalResponse will be created and stored directly within the LocalRequest. Then, a Message will transfer the Response wrapped in a ResponseWrapper back to you, where it can be mapped to your initially created LocalRequest.  You can find an example for the Request-Response flow via Message below.  Sending Requests via RelationshipTemplates  If you don’t have a Relationship with the Recipient yet, the Request needs to be formulated within the onNewRelationship property of the RelationshipTemplateContent. Otherwise, utilize the onExistingRelationship property.  Alternatively, you can transfer Requests via RelationshipTemplates. To do so, you locally create the RelationshipTemplate and in the process the Request, however, no LocalRequest will be created, yet. Hence, the Request your peer receives also doesn’t have an ID, yet. Now, there are two possibilities: either you already have a Relationship with the peer or you wish to establish one, given the condition the peer accepts your Request. For this, you formulate the Request in the content.onExistingRelationship or the content.onNewRelationship property of the RelationshipTemplate, respectively. Note, however, that the content.onNewRelationship property is required and, therefore, must always be set, in order to avoid unstable behavior, if someone you don’t have a Relationship with opens the RelationshipTemplate.  Firstly, let’s consider the case you already have a Relationship with the peer. Receiving your RelationshipTemplate, thus, at their side the content.onExistingRelationship property will be processed, containing your Request. If the peer decides to accept and to respond to the Request, a LocalRequest will be created, comprising the LocalResponse. Its content, i.e. the Response, is wrapped in a ResponseWrapper and sent via Message back to you. Only now, a LocalRequest at your side will be created, having the same ID like its counterpart at your peer’s side, since it was transmitted within the Response. Also, the LocalResponse is stored directly within the LocalRequest, so that the LocalRequest you just created already has the status accepted.  In case you don’t have a Relationship with the peer yet, opening the RelationshipTemplate, its content.onNewRelationship property will be processed. If the peer decides to accept and to respond to your Request, again a LocalRequest and LocalResponse will be created at their side. However, the returned data differ. Instead of a ResponseWrapper inside a Message, a Relationship is returned which is in the status pending for now. It contains the RelationshipTemplate, as well as the changes the peer made to it, i.e. the created Request and Response. Only after you accept the RelationshipCreationChangeRequest (not the kind of Request discussed on this page), the LocalRequest with LocalResponse is created at your side and the peer will receive the information about the status change via a consumption.incomingRequestStatusChanged event.  You can find an example for the Request-Response flow via RelationshipTemplate below.  Examples  Working with required and optional RequestItems  An organization has a Relationship with a customer and needs their consent to the privacy terms. Additionally, the organization would like to know, if the customer is interested in optionally receiving a newsletter. Thus, they send a Request via Message, containing two ConsentRequestItems. On the one hand, the RequestItem regarding consent to the Privacy Terms has the mustBeAccepted flag enabled, indicating that the Request can’t be accepted without accepting this item. On the other hand, the RequestItem regarding the Newsletter has the mustBeAccepted flag disabled. Hence, the customer can freely choose whether or not they would like to give their consent to it. Let’s consider the case the Request and, therefore, the privacy terms are accepted, but the consent to the newsletter is denied. The resulting Request-Response flow is depicted in the following graphic. For simplicity some properties are omitted.    Working with RequestItemGroups  At a job fair a company wants to offer a convenient way to get in touch with interested jobseekers. For this, they provide a QR-code, linking to a RelationshipTemplate. In its content.onNewRelationship property it holds a Request with two RequestItemGroups. One of them contains Attributes the company shares with the peer, e.g. the company name. The other contains Attributes it would like to query from the peer. In this example they are the given and surname and optionally an e-mail address, following the Integration example. Now, an interested person can scan the QR-code, provide their information and send their Response inside a RelationshipCreationChangeRequest. Once the company accepts the new Relationship, they can exchange messages or other data using enmeshed.">


  <meta name="author" content="Enmeshed Team">
  
  <meta property="article:author" content="Enmeshed Team">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="enmeshed">
<meta property="og:title" content="Request and Response introduction">
<meta property="og:url" content="/integrate/request-and-response-introduction">


  <meta property="og:description" content="Requests are the main instrument in enmeshed to interact with other Identities. They enable various business processes, e.g. creating, sharing or receiving Attributes, asking a peer for authentication or consent, and much more. Also, parts of a vaster business process can be implemented with them, like querying all personal information of a user to fill out a tax form.  Requests are unique between Identities and can only be processed once by a single Identity, even across multiple devices associated with them. Each Request can only have a single Response, which responds to the complete Request and contains all the information the requestor needs. The Request-Response flow allows to establish transactional behavior between Identities.  Please note that there are some data structures used in the context of enmeshed, that also use the terms “Request” and “Response” in their name, but do not correspond to the objects described on this page, e.g. RelationshipChangeRequest and RelationshipChangeResponse.  Requests    Structure of Requests  A Request can be created by an Identity and sent to a peer to exchange information with them. Specifying the exact demands to the peer, RequestItems are the core of the Request. In case multiple RequestItems should be answered jointly, e.g. to enhance the structure for the user, they can be combined to a RequestItemGroup. After creating the Request, it can be transmitted either via a Template (see Requests over Templates) or via a Message (see Requests over Messages).  Types of RequestItems  To extinguish different scenarios how to use Requests, there are various types of RequestItems tailored to them.  AuthenticationRequestItem  With the AuthenticationRequestItem the sender can request the peer for an authentication in a business context for a certain purpose. The peer can then decide to authenticate or not. This authentication is mostly short-lived and limited in time.  Examples:     Authentication for a login to a website   Authentication for opening a door   ConsentRequestItem  With the ConsentRequestItem it is possible to request a consent of the peer to an arbitrary text and thus reach agreement on a certain non machine-processable context.  To request an accept/reject decision from a peer to a free text, the ConsentRequestItem is used.  Please do not use the ConsentRequestItem to submit tons of text to the peer Identity. It is meant to be a short consent or summary the user agrees to. Please move longer text to external websites. The ConsentRequestItem is also not meant for contractual agreements.  Examples:     “I hereby confirm that I have read the privacy terms of this cloud service and agree to them.”   “The provided EULA has been read and agreed to.”   “Yes, I have backed up all of my data of this PC and you can wipe it.”   “I opt in to the newsletter.”   CreateAttributeRequestItem  If you want to create Identity- or RelationshipAttributes for the peer, the CreateAttributeRequestItem can be used. Please have a look at the ProposeAttributeRequestItem if the peer should be able to overwrite the Attribute.  To create an Attribute with a fixed value defined by the sender, an Identity uses the CreateAttributeRequestItem. A fixed value in this case means, that the recipient is not allowed to change the value when accepting the request.  Examples of use cases for the CreateAttributeRequestItem can be found in the Create Attribute for peer guide.  FreeTextRequestItem  With the FreeTextRequestItem it is possible to send a free text to the peer. The peer itself can accept this with a free text as well.  ProposeAttributeRequestItem  The ProposeAttributeRequestItem is a combination of ReadAttributeRequestItem and CreateAttributeRequestItem. The sender would like to receive a correct Attribute from the peer, thinks it has a possible value but the peer might overrule this value with an existing or new one.  To create an Attribute with a value proposed by the sender, an Identity uses the ProposeAttributeRequestItem. A proposed value in this case means, that the recipient is allowed to change the value if accepting the request.  Examples of use cases for the ProposeAttributeRequestItem can be found in the Propose Attribute to peer guide.  ReadAttributeRequestItem  If you want to query an Identity’s Attributes this is done with the ReadAttributeRequestItem.  To query Attributes which are not known to the sender, an Identity uses the ReadAttributeRequestItem.  Examples of use cases for the ReadAttributeRequestItem can be found in the Read Attribute from peer guide.  RegisterAttributeListenerRequestItem  This item is used to register a Listener for a specific Attribute. The Listener will create a Request in status Draft if an Attribute was created that matches the given query and the user is able to send the Request to the creator of the RegisterAttributeListenerRequestItem.  Examples:     Asking for a specific RelationshipAttribute of a partner organization.   ShareAttributeRequestItem  If you want to share the own DisplayName and possibly other Attributes this is done with the ShareAttributeRequestItem.  To share own IdentityAttributes (owner = self) an Identity uses the ShareAttributeRequestItem. The Identity needs to create the IdentityAttribute separately before the Attribute can be shared.  Examples of use cases for the ShareAttributeRequestItem can be found in the Share own Attribute to peer guide.  Responses    Structure of Responses  Once the other Identity receives a Request, they can decide whether to accept or reject it. Then, a Response will be created, containing a ResponseItem or ResponseItemGroup for every RequestItem or RequestItemGroup, respectively. The kind of ResponseItem depends on the decision of the Recipient, as well as on the kind of RequestItem.  Types of ResponseItems  There are three different categories of ResponseItems. If a RequestItem is accepted, an AcceptResponseItem will be created. Depending on the kind of RequestItem, it might be a specific AcceptResponseItem, extending the base AcceptResponseItem to answer to RequestItems demanding additional information. For example, a ReadAttributeRequestItem is accepted using a ReadAttributeAcceptResponseItem, additionally transmitting information about the respective Attribute.    If a RequestItem is rejected, however, a RejectResponseItem is created. Lastly, in case the enmeshed Runtime detects a problem, an ErrorResponseItem is generated. It will never be created manually.  Request-Response flow  LocalRequests and LocalResponses  Requests and Responses as discussed above refer to the data structures that are exchanged between Identities. Locally, each Identity stores them in LocalRequests and LocalResponses. Note that the LocalResponse is stored within the respective LocalRequest, besides properties that are common for both peers like the LocalRequestStatus and others that are distinct for each Identity, e.g. the address of the peer or whether the Request was sent by you or received from the peer.  Sending Requests via Messages  Requests can only be send via Message, if you already have an active Relationship with the recipient. Otherwise, you need to utilize a RelationshipTemplate.  If you want to send a Request via Message, firstly you need to create a LocalRequest. Its ID equals the one of the associated Request that is sent in a Message to your peer. If the peer accepts the Request and reponds to it, at their side a LocalRequest will be created, having the same ID, however, opposite values for the fields peer and isOwn. Also, a LocalResponse will be created and stored directly within the LocalRequest. Then, a Message will transfer the Response wrapped in a ResponseWrapper back to you, where it can be mapped to your initially created LocalRequest.  You can find an example for the Request-Response flow via Message below.  Sending Requests via RelationshipTemplates  If you don’t have a Relationship with the Recipient yet, the Request needs to be formulated within the onNewRelationship property of the RelationshipTemplateContent. Otherwise, utilize the onExistingRelationship property.  Alternatively, you can transfer Requests via RelationshipTemplates. To do so, you locally create the RelationshipTemplate and in the process the Request, however, no LocalRequest will be created, yet. Hence, the Request your peer receives also doesn’t have an ID, yet. Now, there are two possibilities: either you already have a Relationship with the peer or you wish to establish one, given the condition the peer accepts your Request. For this, you formulate the Request in the content.onExistingRelationship or the content.onNewRelationship property of the RelationshipTemplate, respectively. Note, however, that the content.onNewRelationship property is required and, therefore, must always be set, in order to avoid unstable behavior, if someone you don’t have a Relationship with opens the RelationshipTemplate.  Firstly, let’s consider the case you already have a Relationship with the peer. Receiving your RelationshipTemplate, thus, at their side the content.onExistingRelationship property will be processed, containing your Request. If the peer decides to accept and to respond to the Request, a LocalRequest will be created, comprising the LocalResponse. Its content, i.e. the Response, is wrapped in a ResponseWrapper and sent via Message back to you. Only now, a LocalRequest at your side will be created, having the same ID like its counterpart at your peer’s side, since it was transmitted within the Response. Also, the LocalResponse is stored directly within the LocalRequest, so that the LocalRequest you just created already has the status accepted.  In case you don’t have a Relationship with the peer yet, opening the RelationshipTemplate, its content.onNewRelationship property will be processed. If the peer decides to accept and to respond to your Request, again a LocalRequest and LocalResponse will be created at their side. However, the returned data differ. Instead of a ResponseWrapper inside a Message, a Relationship is returned which is in the status pending for now. It contains the RelationshipTemplate, as well as the changes the peer made to it, i.e. the created Request and Response. Only after you accept the RelationshipCreationChangeRequest (not the kind of Request discussed on this page), the LocalRequest with LocalResponse is created at your side and the peer will receive the information about the status change via a consumption.incomingRequestStatusChanged event.  You can find an example for the Request-Response flow via RelationshipTemplate below.  Examples  Working with required and optional RequestItems  An organization has a Relationship with a customer and needs their consent to the privacy terms. Additionally, the organization would like to know, if the customer is interested in optionally receiving a newsletter. Thus, they send a Request via Message, containing two ConsentRequestItems. On the one hand, the RequestItem regarding consent to the Privacy Terms has the mustBeAccepted flag enabled, indicating that the Request can’t be accepted without accepting this item. On the other hand, the RequestItem regarding the Newsletter has the mustBeAccepted flag disabled. Hence, the customer can freely choose whether or not they would like to give their consent to it. Let’s consider the case the Request and, therefore, the privacy terms are accepted, but the consent to the newsletter is denied. The resulting Request-Response flow is depicted in the following graphic. For simplicity some properties are omitted.    Working with RequestItemGroups  At a job fair a company wants to offer a convenient way to get in touch with interested jobseekers. For this, they provide a QR-code, linking to a RelationshipTemplate. In its content.onNewRelationship property it holds a Request with two RequestItemGroups. One of them contains Attributes the company shares with the peer, e.g. the company name. The other contains Attributes it would like to query from the peer. In this example they are the given and surname and optionally an e-mail address, following the Integration example. Now, an interested person can scan the QR-code, provide their information and send their Response inside a RelationshipCreationChangeRequest. Once the company accepts the new Relationship, they can exchange messages or other data using enmeshed.">







  <meta property="article:published_time" content="2024-03-05T15:25:26+01:00">






<link rel="canonical" href="/integrate/request-and-response-introduction">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="enmeshed Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <link href="/assets/css/overwrite.css" rel="stylesheet" type="text/css" />

<!-- The following lines are needed because otherwise Prism (the syntax highlighter RapiDoc uses) breaks Rouge (the syntax highlighter we use) -->
<script>
    window.Prism = window.Prism || {};
    Prism.manual = true;
</script>
<script type="module" src="https://unpkg.com/rapidoc/dist/rapidoc-min.js"></script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          enmeshed
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/use">Use</a>
            </li><li class="masthead__menu-item">
              <a href="/explore">Explore</a>
            </li><li class="masthead__menu-item">
              <a href="/integrate">Integrate</a>
            </li><li class="masthead__menu-item">
              <a href="/operate">Operate</a>
            </li><li class="masthead__menu-item">
              <a href="/contribute">Contribute</a>
            </li><li class="masthead__menu-item">
              <a href="/blog">Blog</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      <h3>Integrate enmeshed</h3>
      
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Getting Started</span>
        

        
        <ul>
          
            <li><a href="/integrate/access-the-connector">Access the Connector</a></li>
          
            <li><a href="/integrate/integration-example">Integration example</a></li>
          
            <li><a href="/integrate/event-introduction">Event introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Working with requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/request-and-response-introduction" class="active">Request and Response introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage Requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/requests-over-templates">Requests over Templates</a></li>
          
            <li><a href="/integrate/requests-over-messages">Requests over Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of yourself</span>
        

        
        <ul>
          
            <li><a href="/integrate/create-attribute-for-yourself">Create Attribute for yourself</a></li>
          
            <li><a href="/integrate/share-own-attribute-to-peer">Share own Attribute to peer</a></li>
          
            <li><a href="/integrate/succeeding-attributes-to-update-their-values">Succeeding Attributes to update their values</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of others</span>
        

        
        <ul>
          
            <li><a href="/integrate/read-attribute-from-peer">Read Attribute from peer</a></li>
          
            <li><a href="/integrate/create-attribute-for-peer">Create Attribute for peer</a></li>
          
            <li><a href="/integrate/propose-attribute-to-peer">Propose Attribute to peer</a></li>
          
            <li><a href="/integrate/request-persistent-consent-of-peer">Request persistent consent of peer</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Basic communication</span>
        

        
        <ul>
          
            <li><a href="/integrate/sending-messages">Sending Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Requesting consent of users</span>
        

        
        <ul>
          
            <li><a href="/integrate/requesting-one-time-consents">Requesting one-time consents</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Data Model</span>
        

        
        <ul>
          
            <li><a href="/integrate/use-cases">Use Cases</a></li>
          
            <li><a href="/integrate/data-model-overview">Data Model Overview</a></li>
          
            <li><a href="/integrate/connector-events">Connector Events</a></li>
          
            <li><a href="/integrate/requests-and-requestitems">Requests and RequestItems</a></li>
          
            <li><a href="/integrate/attribute-values">Attribute Values</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Troubleshooting</span>
        

        
        <ul>
          
            <li><a href="/integrate/error-codes">Error Codes</a></li>
          
            <li><a href="/integrate/faq">FAQ</a></li>
          
            <li><a href="/integrate/support">Support</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Request and Response introduction">
    <meta itemprop="description" content="Requests are the main instrument in enmeshed to interact with other Identities.They enable various business processes, e.g. creating, sharing or receiving Attributes, asking a peer for authentication or consent, and much more.Also, parts of a vaster business process can be implemented with them, like querying all personal information of a user to fill out a tax form.Requests are unique between Identities and can only be processed once by a single Identity, even across multiple devices associated with them.Each Request can only have a single Response, which responds to the complete Request and contains all the information the requestor needs.The Request-Response flow allows to establish transactional behavior between Identities.Please note that there are some data structures used in the context of enmeshed, that also use the terms “Request” and “Response” in their name, but do not correspond to the objects described on this page, e.g. RelationshipChangeRequest and RelationshipChangeResponse.RequestsStructure of RequestsA Request can be created by an Identity and sent to a peer to exchange information with them.Specifying the exact demands to the peer, RequestItems are the core of the Request.In case multiple RequestItems should be answered jointly, e.g. to enhance the structure for the user, they can be combined to a RequestItemGroup.After creating the Request, it can be transmitted either via a Template (see Requests over Templates) or via a Message (see Requests over Messages).Types of RequestItemsTo extinguish different scenarios how to use Requests, there are various types of RequestItems tailored to them.AuthenticationRequestItemWith the AuthenticationRequestItem the sender can request the peer for an authentication in a business context for a certain purpose. The peer can then decide to authenticate or not. This authentication is mostly short-lived and limited in time.Examples:  Authentication for a login to a website  Authentication for opening a doorConsentRequestItemWith the ConsentRequestItem it is possible to request a consent of the peer to an arbitrary text and thus reach agreement on a certain non machine-processable context.To request an accept/reject decision from a peer to a free text, the ConsentRequestItem is used.Please do not use the ConsentRequestItem to submit tons of text to the peer Identity. It is meant to be a short consent or summary the user agrees to. Please move longer text to external websites.The ConsentRequestItem is also not meant for contractual agreements.Examples:  “I hereby confirm that I have read the privacy terms of this cloud service and agree to them.”  “The provided EULA has been read and agreed to.”  “Yes, I have backed up all of my data of this PC and you can wipe it.”  “I opt in to the newsletter.”CreateAttributeRequestItemIf you want to create Identity- or RelationshipAttributes for the peer, the CreateAttributeRequestItem can be used. Please have a look at the ProposeAttributeRequestItem if the peer should be able to overwrite the Attribute.To create an Attribute with a fixed value defined by the sender, an Identity uses the CreateAttributeRequestItem. A fixed value in this case means, that the recipient is not allowed to change the value when accepting the request.Examples of use cases for the CreateAttributeRequestItem can be found in the Create Attribute for peer guide.FreeTextRequestItemWith the FreeTextRequestItem it is possible to send a free text to the peer. The peer itself can accept this with a free text as well.ProposeAttributeRequestItemThe ProposeAttributeRequestItem is a combination of ReadAttributeRequestItem and CreateAttributeRequestItem. The sender would like to receive a correct Attribute from the peer, thinks it has a possible value but the peer might overrule this value with an existing or new one.To create an Attribute with a value proposed by the sender, an Identity uses the ProposeAttributeRequestItem. A proposed value in this case means, that the recipient is allowed to change the value if accepting the request.Examples of use cases for the ProposeAttributeRequestItem can be found in the Propose Attribute to peer guide.ReadAttributeRequestItemIf you want to query an Identity’s Attributes this is done with the ReadAttributeRequestItem.To query Attributes which are not known to the sender, an Identity uses the ReadAttributeRequestItem.Examples of use cases for the ReadAttributeRequestItem can be found in the Read Attribute from peer guide.RegisterAttributeListenerRequestItemThis item is used to register a Listener for a specific Attribute. The Listener will create a Request in status Draft if an Attribute was created that matches the given query and the user is able to send the Request to the creator of the RegisterAttributeListenerRequestItem.Examples:  Asking for a specific RelationshipAttribute of a partner organization.ShareAttributeRequestItemIf you want to share the own DisplayName and possibly other Attributes this is done with the ShareAttributeRequestItem.To share own IdentityAttributes (owner = self) an Identity uses the ShareAttributeRequestItem. The Identity needs to create the IdentityAttribute separately before the Attribute can be shared.Examples of use cases for the ShareAttributeRequestItem can be found in the Share own Attribute to peer guide.ResponsesStructure of ResponsesOnce the other Identity receives a Request, they can decide whether to accept or reject it.Then, a Response will be created, containing a ResponseItem or ResponseItemGroup for every RequestItem or RequestItemGroup, respectively.The kind of ResponseItem depends on the decision of the Recipient, as well as on the kind of RequestItem.Types of ResponseItemsThere are three different categories of ResponseItems.If a RequestItem is accepted, an AcceptResponseItem will be created.Depending on the kind of RequestItem, it might be a specific AcceptResponseItem, extending the base AcceptResponseItem to answer to RequestItems demanding additional information.For example, a ReadAttributeRequestItem is accepted using a ReadAttributeAcceptResponseItem, additionally transmitting information about the respective Attribute.If a RequestItem is rejected, however, a RejectResponseItem is created.Lastly, in case the enmeshed Runtime detects a problem, an ErrorResponseItem is generated.It will never be created manually.Request-Response flowLocalRequests and LocalResponsesRequests and Responses as discussed above refer to the data structures that are exchanged between Identities.Locally, each Identity stores them in LocalRequests and LocalResponses.Note that the LocalResponse is stored within the respective LocalRequest, besides properties that are common for both peers like the LocalRequestStatus and others that are distinct for each Identity, e.g. the address of the peer or whether the Request was sent by you or received from the peer.Sending Requests via MessagesRequests can only be send via Message, if you already have an active Relationship with the recipient.Otherwise, you need to utilize a RelationshipTemplate.If you want to send a Request via Message, firstly you need to create a LocalRequest.Its ID equals the one of the associated Request that is sent in a Message to your peer.If the peer accepts the Request and reponds to it, at their side a LocalRequest will be created, having the same ID, however, opposite values for the fields peer and isOwn.Also, a LocalResponse will be created and stored directly within the LocalRequest.Then, a Message will transfer the Response wrapped in a ResponseWrapper back to you, where it can be mapped to your initially created LocalRequest.You can find an example for the Request-Response flow via Message below.Sending Requests via RelationshipTemplatesIf you don’t have a Relationship with the Recipient yet, the Request needs to be formulated within the onNewRelationship property of the RelationshipTemplateContent.Otherwise, utilize the onExistingRelationship property.Alternatively, you can transfer Requests via RelationshipTemplates.To do so, you locally create the RelationshipTemplate and in the process the Request, however, no LocalRequest will be created, yet.Hence, the Request your peer receives also doesn’t have an ID, yet.Now, there are two possibilities: either you already have a Relationship with the peer or you wish to establish one, given the condition the peer accepts your Request.For this, you formulate the Request in the content.onExistingRelationship or the content.onNewRelationship property of the RelationshipTemplate, respectively.Note, however, that the content.onNewRelationship property is required and, therefore, must always be set, in order to avoid unstable behavior, if someone you don’t have a Relationship with opens the RelationshipTemplate.Firstly, let’s consider the case you already have a Relationship with the peer.Receiving your RelationshipTemplate, thus, at their side the content.onExistingRelationship property will be processed, containing your Request.If the peer decides to accept and to respond to the Request, a LocalRequest will be created, comprising the LocalResponse.Its content, i.e. the Response, is wrapped in a ResponseWrapper and sent via Message back to you.Only now, a LocalRequest at your side will be created, having the same ID like its counterpart at your peer’s side, since it was transmitted within the Response.Also, the LocalResponse is stored directly within the LocalRequest, so that the LocalRequest you just created already has the status accepted.In case you don’t have a Relationship with the peer yet, opening the RelationshipTemplate, its content.onNewRelationship property will be processed.If the peer decides to accept and to respond to your Request, again a LocalRequest and LocalResponse will be created at their side.However, the returned data differ.Instead of a ResponseWrapper inside a Message, a Relationship is returned which is in the status pending for now.It contains the RelationshipTemplate, as well as the changes the peer made to it, i.e. the created Request and Response.Only after you accept the RelationshipCreationChangeRequest (not the kind of Request discussed on this page), the LocalRequest with LocalResponse is created at your side and the peer will receive the information about the status change via a consumption.incomingRequestStatusChanged event.You can find an example for the Request-Response flow via RelationshipTemplate below.ExamplesWorking with required and optional RequestItemsAn organization has a Relationship with a customer and needs their consent to the privacy terms.Additionally, the organization would like to know, if the customer is interested in optionally receiving a newsletter.Thus, they send a Request via Message, containing two ConsentRequestItems.On the one hand, the RequestItem regarding consent to the Privacy Terms has the mustBeAccepted flag enabled, indicating that the Request can’t be accepted without accepting this item.On the other hand, the RequestItem regarding the Newsletter has the mustBeAccepted flag disabled.Hence, the customer can freely choose whether or not they would like to give their consent to it.Let’s consider the case the Request and, therefore, the privacy terms are accepted, but the consent to the newsletter is denied.The resulting Request-Response flow is depicted in the following graphic.For simplicity some properties are omitted.Working with RequestItemGroupsAt a job fair a company wants to offer a convenient way to get in touch with interested jobseekers.For this, they provide a QR-code, linking to a RelationshipTemplate.In its content.onNewRelationship property it holds a Request with two RequestItemGroups.One of them contains Attributes the company shares with the peer, e.g. the company name.The other contains Attributes it would like to query from the peer.In this example they are the given and surname and optionally an e-mail address, following the Integration example.Now, an interested person can scan the QR-code, provide their information and send their Response inside a RelationshipCreationChangeRequest.Once the company accepts the new Relationship, they can exchange messages or other data using enmeshed.">
    <meta itemprop="datePublished" content="2024-03-05T15:25:26+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="/integrate/request-and-response-introduction" class="u-url" itemprop="url">Request and Response introduction
</a>
          </h1>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#requests">Requests</a><ul><li><a href="#structure-of-requests">Structure of Requests</a></li><li><a href="#types-of-requestitems">Types of RequestItems</a><ul><li><a href="#authenticationrequestitem">AuthenticationRequestItem</a></li><li><a href="#consentrequestitem">ConsentRequestItem</a></li><li><a href="#createattributerequestitem">CreateAttributeRequestItem</a></li><li><a href="#freetextrequestitem">FreeTextRequestItem</a></li><li><a href="#proposeattributerequestitem">ProposeAttributeRequestItem</a></li><li><a href="#readattributerequestitem">ReadAttributeRequestItem</a></li><li><a href="#registerattributelistenerrequestitem">RegisterAttributeListenerRequestItem</a></li><li><a href="#shareattributerequestitem">ShareAttributeRequestItem</a></li></ul></li></ul></li><li><a href="#responses">Responses</a><ul><li><a href="#structure-of-responses">Structure of Responses</a></li><li><a href="#types-of-responseitems">Types of ResponseItems</a></li></ul></li><li><a href="#request-response-flow">Request-Response flow</a><ul><li><a href="#localrequests-and-localresponses">LocalRequests and LocalResponses</a></li><li><a href="#sending-requests-via-messages">Sending Requests via Messages</a></li><li><a href="#sending-requests-via-relationshiptemplates">Sending Requests via RelationshipTemplates</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#working-with-required-and-optional-requestitems">Working with required and optional RequestItems</a></li><li><a href="#working-with-requestitemgroups">Working with RequestItemGroups</a></li></ul></li></ul>

            </nav>
          </aside>
        
        <p>Requests are the main instrument in enmeshed to interact with other Identities.
They enable various business processes, e.g. creating, sharing or receiving Attributes, asking a peer for authentication or consent, and much more.
Also, parts of a vaster business process can be implemented with them, like querying all personal information of a user to fill out a tax form.</p>

<p>Requests are unique between Identities and can only be processed once by a single Identity, even across multiple devices associated with them.
Each Request can only have a single Response, which responds to the complete Request and contains all the information the requestor needs.
The Request-Response flow allows to establish transactional behavior between Identities.</p>

<p>Please note that there are some data structures used in the context of enmeshed, that also use the terms “Request” and “Response” in their name, but do not correspond to the objects described on this page, e.g. <a href="/integrate/data-model-overview#relationshipchangerequest">RelationshipChangeRequest</a> and <a href="/integrate/data-model-overview#relationshipchangeresponse">RelationshipChangeResponse</a>.</p>

<h2 id="requests">Requests</h2>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/03ed5248-af12-4a50-bac1-73831f2c3cf9" id="d~qRE5C7Dqig"></iframe></div>

<h3 id="structure-of-requests">Structure of Requests</h3>

<p>A <a href="/integrate/data-model-overview#request">Request</a> can be created by an Identity and sent to a peer to exchange information with them.
Specifying the exact demands to the peer, <a href="/integrate/data-model-overview#requestitems">RequestItems</a> are the core of the Request.
In case multiple RequestItems should be answered jointly, e.g. to enhance the structure for the user, they can be combined to a <a href="/integrate/data-model-overview#requestitemgroup">RequestItemGroup</a>.
After creating the Request, it can be transmitted either via a Template (see <a href="/integrate/requests-over-templates">Requests over Templates</a>) or via a Message (see <a href="/integrate/requests-over-messages">Requests over Messages</a>).</p>

<h3 id="types-of-requestitems">Types of RequestItems</h3>

<p>To extinguish different scenarios how to use Requests, there are various types of RequestItems tailored to them.</p>

<h4 id="authenticationrequestitem">AuthenticationRequestItem</h4>

<p>With the <a href="/integrate/data-model-overview#authenticationrequestitem">AuthenticationRequestItem</a> the sender can request the peer for an authentication in a business context for a certain purpose. The peer can then decide to authenticate or not. This authentication is mostly short-lived and limited in time.</p>

<p>Examples:</p>

<ul>
  <li>Authentication for a login to a website</li>
  <li>Authentication for opening a door</li>
</ul>

<h4 id="consentrequestitem">ConsentRequestItem</h4>

<p>With the <a href="/integrate/data-model-overview#consentrequestitem">ConsentRequestItem</a> it is possible to request a consent of the peer to an arbitrary text and thus reach agreement on a certain non machine-processable context.</p>

<p>To request an accept/reject decision from a peer to a free text, the ConsentRequestItem is used.</p>

<p class="notice--info">Please do not use the ConsentRequestItem to submit tons of text to the peer Identity. It is meant to be a short consent or summary the user agrees to. Please move longer text to external websites.
The ConsentRequestItem is also not meant for contractual agreements.</p>

<p>Examples:</p>

<ul>
  <li>“I hereby confirm that I have read the privacy terms of this cloud service and agree to them.”</li>
  <li>“The provided EULA has been read and agreed to.”</li>
  <li>“Yes, I have backed up all of my data of this PC and you can wipe it.”</li>
  <li>“I opt in to the newsletter.”</li>
</ul>

<h4 id="createattributerequestitem">CreateAttributeRequestItem</h4>

<p>If you want to create Identity- or RelationshipAttributes for the peer, the <a href="/integrate/data-model-overview#createattributerequestitem">CreateAttributeRequestItem</a> can be used. Please have a look at the <a href="#proposeattributerequestitem">ProposeAttributeRequestItem</a> if the peer should be able to overwrite the Attribute.</p>

<p>To create an Attribute with a fixed value defined by the sender, an Identity uses the CreateAttributeRequestItem. A fixed value in this case means, that the recipient is not allowed to change the value when accepting the request.</p>

<p>Examples of use cases for the CreateAttributeRequestItem can be found in the <a href="/integrate/create-attribute-for-peer">Create Attribute for peer</a> guide.</p>

<h4 id="freetextrequestitem">FreeTextRequestItem</h4>

<p>With the <a href="/integrate/data-model-overview#freetextrequestitem">FreeTextRequestItem</a> it is possible to send a free text to the peer. The peer itself can accept this with a free text as well.</p>

<h4 id="proposeattributerequestitem">ProposeAttributeRequestItem</h4>

<p>The <a href="/integrate/data-model-overview#proposeattributerequestitem">ProposeAttributeRequestItem</a> is a combination of <a href="#readattributerequestitem">ReadAttributeRequestItem</a> and <a href="#createattributerequestitem">CreateAttributeRequestItem</a>. The sender would like to receive a correct Attribute from the peer, thinks it has a possible value but the peer might overrule this value with an existing or new one.</p>

<p>To create an Attribute with a value proposed by the sender, an Identity uses the ProposeAttributeRequestItem. A proposed value in this case means, that the recipient is allowed to change the value if accepting the request.</p>

<p>Examples of use cases for the ProposeAttributeRequestItem can be found in the <a href="/integrate/propose-attribute-to-peer">Propose Attribute to peer</a> guide.</p>

<h4 id="readattributerequestitem">ReadAttributeRequestItem</h4>

<p>If you want to query an Identity’s Attributes this is done with the <a href="/integrate/data-model-overview#readattributerequestitem">ReadAttributeRequestItem</a>.</p>

<p>To query Attributes which are not known to the sender, an Identity uses the ReadAttributeRequestItem.</p>

<p>Examples of use cases for the ReadAttributeRequestItem can be found in the <a href="/integrate/read-attribute-from-peer">Read Attribute from peer</a> guide.</p>

<h4 id="registerattributelistenerrequestitem">RegisterAttributeListenerRequestItem</h4>

<p>This item is used to register a <a href="/integrate/data-model-overview#localattributelistener">Listener</a> for a specific Attribute. The Listener will create a Request in status <code class="language-plaintext highlighter-rouge">Draft</code> if an Attribute was created that matches the given query and the user is able to send the Request to the creator of the <a href="/integrate/data-model-overview#registerattributelistenerrequestitem">RegisterAttributeListenerRequestItem</a>.</p>

<p>Examples:</p>

<ul>
  <li>Asking for a specific RelationshipAttribute of a partner organization.</li>
</ul>

<h4 id="shareattributerequestitem">ShareAttributeRequestItem</h4>

<p>If you want to share the own DisplayName and possibly other Attributes this is done with the <a href="/integrate/data-model-overview#shareattributerequestitem">ShareAttributeRequestItem</a>.</p>

<p>To share own IdentityAttributes (owner = self) an Identity uses the ShareAttributeRequestItem. The Identity needs to create the IdentityAttribute separately before the Attribute can be shared.</p>

<p>Examples of use cases for the ShareAttributeRequestItem can be found in the <a href="/integrate/share-own-attribute-to-peer">Share own Attribute to peer</a> guide.</p>

<h2 id="responses">Responses</h2>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/b42bc3d1-bb48-4bd5-a645-016dce559b30" id="Y.qRU24GDTrY"></iframe></div>

<h3 id="structure-of-responses">Structure of Responses</h3>

<p>Once the other Identity receives a Request, they can decide whether to accept or reject it.
Then, a <a href="/integrate/data-model-overview#response">Response</a> will be created, containing a <a href="/integrate/data-model-overview#responseitem">ResponseItem</a> or <a href="/integrate/data-model-overview#responseitemgroup">ResponseItemGroup</a> for every RequestItem or RequestItemGroup, respectively.
The kind of ResponseItem depends on the decision of the Recipient, as well as on the kind of RequestItem.</p>

<h3 id="types-of-responseitems">Types of ResponseItems</h3>

<p>There are three different categories of ResponseItems.
If a RequestItem is accepted, an <a href="/integrate/data-model-overview#acceptresponseitem">AcceptResponseItem</a> will be created.
Depending on the kind of RequestItem, it might be a specific AcceptResponseItem, extending the base AcceptResponseItem to answer to RequestItems demanding additional information.
For example, a ReadAttributeRequestItem is accepted using a <a href="/integrate/data-model-overview#readattributeacceptresponseitem">ReadAttributeAcceptResponseItem</a>, additionally transmitting information about the respective Attribute.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/1d3f3866-4d85-46b5-8523-ecc581052f4b" id="NCvNTKLN71pl"></iframe></div>

<p>If a RequestItem is rejected, however, a <a href="/integrate/data-model-overview#rejectresponseitem">RejectResponseItem</a> is created.
Lastly, in case the enmeshed Runtime detects a problem, an <a href="/integrate/data-model-overview#errorresponseitem">ErrorResponseItem</a> is generated.
It will never be created manually.</p>

<h2 id="request-response-flow">Request-Response flow</h2>

<h3 id="localrequests-and-localresponses">LocalRequests and LocalResponses</h3>

<p>Requests and Responses as discussed above refer to the data structures that are exchanged between Identities.
Locally, each Identity stores them in <a href="/integrate/data-model-overview#localrequest">LocalRequests</a> and <a href="/integrate/data-model-overview#localresponse">LocalResponses</a>.
Note that the LocalResponse is stored within the respective LocalRequest, besides properties that are common for both peers like the <a href="/integrate/data-model-overview#localrequeststatus">LocalRequestStatus</a> and others that are distinct for each Identity, e.g. the address of the peer or whether the Request was sent by you or received from the peer.</p>

<h3 id="sending-requests-via-messages">Sending Requests via Messages</h3>

<p class="notice--info">Requests can only be send via Message, if you already have an active Relationship with the recipient.
Otherwise, you need to utilize a <a href="#sending-requests-via-relationshiptemplates">RelationshipTemplate</a>.</p>

<p>If you want to send a <a href="/integrate/requests-over-messages">Request via Message</a>, firstly you need to create a LocalRequest.
Its ID equals the one of the associated Request that is sent in a <a href="/integrate/data-model-overview#message">Message</a> to your peer.
If the peer accepts the Request and reponds to it, at their side a LocalRequest will be created, having the same ID, however, opposite values for the fields <code class="language-plaintext highlighter-rouge">peer</code> and <code class="language-plaintext highlighter-rouge">isOwn</code>.
Also, a LocalResponse will be created and stored directly within the LocalRequest.
Then, a Message will transfer the Response wrapped in a <a href="/integrate/data-model-overview#responsewrapper">ResponseWrapper</a> back to you, where it can be mapped to your initially created LocalRequest.</p>

<p>You can find an <a href="#working-with-required-and-optional-requestitems">example for the Request-Response flow via Message</a> below.</p>

<h3 id="sending-requests-via-relationshiptemplates">Sending Requests via RelationshipTemplates</h3>

<p class="notice--info">If you don’t have a Relationship with the Recipient yet, the Request needs to be formulated within the <code class="language-plaintext highlighter-rouge">onNewRelationship</code> property of the <a href="/integrate/data-model-overview#relationshiptemplatecontent">RelationshipTemplateContent</a>.
Otherwise, utilize the <code class="language-plaintext highlighter-rouge">onExistingRelationship</code> property.</p>

<p>Alternatively, you can transfer <a href="/integrate/requests-over-templates">Requests via RelationshipTemplates</a>.
To do so, you locally create the <a href="/integrate/data-model-overview#relationshiptemplate">RelationshipTemplate</a> and in the process the Request, however, no LocalRequest will be created, yet.
Hence, the Request your peer receives also doesn’t have an ID, yet.
Now, there are two possibilities: either you already have a Relationship with the peer or you wish to establish one, given the condition the peer accepts your Request.
For this, you formulate the Request in the <code class="language-plaintext highlighter-rouge">content.onExistingRelationship</code> or the <code class="language-plaintext highlighter-rouge">content.onNewRelationship</code> property of the RelationshipTemplate, respectively.
Note, however, that the <code class="language-plaintext highlighter-rouge">content.onNewRelationship</code> property is required and, therefore, must always be set, in order to avoid unstable behavior, if someone you don’t have a Relationship with opens the RelationshipTemplate.</p>

<p>Firstly, let’s consider the case you already have a Relationship with the peer.
Receiving your RelationshipTemplate, thus, at their side the <code class="language-plaintext highlighter-rouge">content.onExistingRelationship</code> property will be processed, containing your Request.
If the peer decides to accept and to respond to the Request, a LocalRequest will be created, comprising the LocalResponse.
Its content, i.e. the Response, is wrapped in a ResponseWrapper and sent via Message back to you.
Only now, a LocalRequest at your side will be created, having the same ID like its counterpart at your peer’s side, since it was transmitted within the Response.
Also, the LocalResponse is stored directly within the LocalRequest, so that the LocalRequest you just created already has the status <code class="language-plaintext highlighter-rouge">accepted</code>.</p>

<p>In case you don’t have a Relationship with the peer yet, opening the RelationshipTemplate, its <code class="language-plaintext highlighter-rouge">content.onNewRelationship</code> property will be processed.
If the peer decides to accept and to respond to your Request, again a LocalRequest and LocalResponse will be created at their side.
However, the returned data differ.
Instead of a ResponseWrapper inside a Message, a Relationship is returned which is in the status <code class="language-plaintext highlighter-rouge">pending</code> for now.
It contains the RelationshipTemplate, as well as the changes the peer made to it, i.e. the created Request and Response.
Only after you accept the RelationshipCreationChangeRequest (not the kind of Request discussed on this page), the LocalRequest with LocalResponse is created at your side and the peer will receive the information about the status change via a <code class="language-plaintext highlighter-rouge">consumption.incomingRequestStatusChanged</code> <a href="/integrate/connector-events">event</a>.</p>

<p>You can find an <a href="#working-with-requestitemgroups">example for the Request-Response flow via RelationshipTemplate</a> below.</p>

<h2 id="examples">Examples</h2>

<h3 id="working-with-required-and-optional-requestitems">Working with required and optional RequestItems</h3>

<p>An organization has a Relationship with a customer and needs their consent to the privacy terms.
Additionally, the organization would like to know, if the customer is interested in optionally receiving a newsletter.
Thus, they send a Request via Message, containing two ConsentRequestItems.
On the one hand, the RequestItem regarding consent to the Privacy Terms has the <code class="language-plaintext highlighter-rouge">mustBeAccepted</code> flag enabled, indicating that the Request can’t be accepted without accepting this item.
On the other hand, the RequestItem regarding the Newsletter has the <code class="language-plaintext highlighter-rouge">mustBeAccepted</code> flag disabled.
Hence, the customer can freely choose whether or not they would like to give their consent to it.
Let’s consider the case the Request and, therefore, the privacy terms are accepted, but the consent to the newsletter is denied.
The resulting Request-Response flow is depicted in the following graphic.
For simplicity some properties are omitted.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/8989a397-d7e8-4c3c-b447-0d9043da8ceb" id="7CvNv9u5~~Sl"></iframe></div>

<h3 id="working-with-requestitemgroups">Working with RequestItemGroups</h3>

<p>At a job fair a company wants to offer a convenient way to get in touch with interested jobseekers.
For this, they provide a QR-code, linking to a RelationshipTemplate.
In its <code class="language-plaintext highlighter-rouge">content.onNewRelationship</code> property it holds a Request with two RequestItemGroups.
One of them contains Attributes the company shares with the peer, e.g. the company name.
The other contains Attributes it would like to query from the peer.
In this example they are the given and surname and optionally an e-mail address, following the <a href="/integrate/integration-example">Integration example</a>.
Now, an interested person can scan the QR-code, provide their information and send their Response inside a RelationshipCreationChangeRequest.
Once the company accepts the new Relationship, they can exchange messages or other data using enmeshed.</p>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen="" frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embedded/4ac53380-b21a-4e33-982a-aa9167c471f3" id="iDvN-GT-yvbN"></iframe></div>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2024-03-05T15:25:26+01:00">March 5, 2024</time></p>

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
           
        <li>
            <a href="/legal" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-info" aria-hidden="true"></i> Legal Disclosure</a>
        </li>
          
        <li>
            <a href="/privacy" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-user-shield" aria-hidden="true"></i> Privacy Statement</a>
        </li>
          
        <li>
            <a href="https://www.enmeshed.eu" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Website</a>
        </li>
          
        <li>
            <a href="https://github.com/nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a>
        </li>
          
        <li>
            <a href="https://www.npmjs.com/search?q=%40nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-npm" aria-hidden="true"></i> NPM</a>
        </li>
           
        <li>
            <a href="/feed.xml"
                ><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a
            >
        </li>
        
    </ul>
</div>

<div class="page__footer-copyright">
    &copy; 2024
    <a href="https://www.js-soft.com">j&amp;s-soft GmbH</a>. Powered by
    <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
