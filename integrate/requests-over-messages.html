<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Requests over Messages - enmeshed</title>
<meta name="description" content="This guide explains how to send and receive a Request over enmeshed Messages using two Connectors, the first of which sends a Request to the second, and the second accepts or rejects the Request. It provides step-by-step instructions for validating the Request, creating and sending the Request, and accepting or rejecting the Request.      This guide assumes that you already have an active Relationship between two Connectors. If you don’t, you should follow the Requests over Templates guide first. If you created a Relationship during the Connector Tutorial this will also work.  In this guide, the first Connector will be called Sender and the second Connector will be called Recipient. The Sender will send a Request to the Recipient. For the next steps you will need the enmeshed Address of the Recipient. You can find it out by calling the GET /api/v2/Relationships route on the Sender Connector.  [   // ...   {     &quot;id&quot;: &quot;REL..&quot;,     &quot;status&quot;: &quot;Active&quot;,     // ...     &quot;peer&quot;: &quot;id1...&quot;   } ]                          Look for the correct Relationship and then take its peer property. Save it for later.         Check your Requests validity  At first you should check if your Request is valid. You can do this by calling the POST /api/v2/Requests/Outgoing/Validate route on the Sender Connector with the following body. For simplicity the Request inside the Template only contains an AuthenticationRequestItem, but you can use any RequestItems you want.  Even though the peer property is optional, it is recommended to specify it whenever possible. This allows additional validation rules to execute. When you are sending a Request over Messages you always know your peer.  {   &quot;content&quot;: {     &quot;items&quot;: [       {         &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,         &quot;mustBeAccepted&quot;: true,         &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;       }     ]   },   &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot; }   Create the Request  To create the Request you have to call the POST /api/v2/Requests/Outgoing route on the Sender Connector. Use the following JSON in the Request body:  {   &quot;content&quot;: {     // the content property of the payload in the step before   },   &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot; }   Note that the Request is currently in status Draft.                         Save the complete content of the response. You will need it in the next step.         Example response:  {   &quot;id&quot;: &quot;REQ...&quot;,   &quot;status&quot;: &quot;Draft&quot;,   // ...   &quot;content&quot;: {     &quot;@type&quot;: &quot;Request&quot;,     &quot;id&quot;: &quot;REQ...&quot;,     &quot;items&quot;: [       {         &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,         &quot;mustBeAccepted&quot;: true,         &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;       }     ]   } }   Send the Request  Now you have to send the Request to the Recipient. You can do so by calling the POST /api/v2/Messages route on the Sender Connector. Use the following JSON in the Request body:  {   &quot;recipients&quot;: [&quot;&lt;the address of the Recipient Connector&gt;&quot;],   &quot;content&quot;: {     // the content you copied in the step before   } }   This is where the automation of the enmeshed Runtime steps in and moves the Request from status Draft to status Open. You can observe this behaviour by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.  Fetch the Request  In order to fetch the Message with the Request, you have to synchronize the Recipient Connector (GET /api/v2/Account/Sync).  The enmeshed Runtime will read the Message and create a new incoming Request. You can observe this by long polling the incoming Requests or by waiting for the consumption.incomingRequestReceived event.  The long polling is done by calling the GET /api/v2/Requests/Incoming route. You can use the query params source.reference=&lt;id-of-the-message&gt; and status=ManualDecisionRequired to filter for Requests that belong to the Message that contained the Request.  For more information about the events you can head over to the Connector Modules site and read about the AMQP Publisher module and the Webhooks module that are propagating events.                         After you received the Request, save its id for the next step.         Answer the Request  Accept  If you want to accept the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Accept route. You can use the id you saved in the previous step. In the payload you have to accept at least all RequestItems where the mustBeAccepted property is set to true. In case of the example Request the payload is the following:  {   &quot;items&quot;: [     {       &quot;accept&quot;: true     }   ] }   Reject  If you want to reject the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Reject route. You can use the id you saved in the previous step. In the payload you have to reject all RequestItems. In case of the example Request the payload is the following:  {   &quot;items&quot;: [     {       &quot;accept&quot;: false     }   ] }   Runtime automation  No matter if you accepted or rejected the Request: the response is similar. You can see that the Request moved to status Decided. This is where the enmeshed Runtime steps in and handles the Request based on you decision. It will move the Request to status Completed and send the Response to the Sender via a Message. This behavior can be observed by querying the Request again after a few seconds (GET /api/v2/Requests/Incoming/{id}).  Sync the Response  The Sender will receive the Response as a Message. Therefore you have to synchronize the Sender Connector (GET /api/v2/Account/Sync).  After a few seconds the Request has moved to status Completed and the Response is available in the response property of the Request. You can observe this by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.">


  <meta name="author" content="Enmeshed Team">
  
  <meta property="article:author" content="Enmeshed Team">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="enmeshed">
<meta property="og:title" content="Requests over Messages">
<meta property="og:url" content="/integrate/requests-over-messages">


  <meta property="og:description" content="This guide explains how to send and receive a Request over enmeshed Messages using two Connectors, the first of which sends a Request to the second, and the second accepts or rejects the Request. It provides step-by-step instructions for validating the Request, creating and sending the Request, and accepting or rejecting the Request.      This guide assumes that you already have an active Relationship between two Connectors. If you don’t, you should follow the Requests over Templates guide first. If you created a Relationship during the Connector Tutorial this will also work.  In this guide, the first Connector will be called Sender and the second Connector will be called Recipient. The Sender will send a Request to the Recipient. For the next steps you will need the enmeshed Address of the Recipient. You can find it out by calling the GET /api/v2/Relationships route on the Sender Connector.  [   // ...   {     &quot;id&quot;: &quot;REL..&quot;,     &quot;status&quot;: &quot;Active&quot;,     // ...     &quot;peer&quot;: &quot;id1...&quot;   } ]                          Look for the correct Relationship and then take its peer property. Save it for later.         Check your Requests validity  At first you should check if your Request is valid. You can do this by calling the POST /api/v2/Requests/Outgoing/Validate route on the Sender Connector with the following body. For simplicity the Request inside the Template only contains an AuthenticationRequestItem, but you can use any RequestItems you want.  Even though the peer property is optional, it is recommended to specify it whenever possible. This allows additional validation rules to execute. When you are sending a Request over Messages you always know your peer.  {   &quot;content&quot;: {     &quot;items&quot;: [       {         &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,         &quot;mustBeAccepted&quot;: true,         &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;       }     ]   },   &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot; }   Create the Request  To create the Request you have to call the POST /api/v2/Requests/Outgoing route on the Sender Connector. Use the following JSON in the Request body:  {   &quot;content&quot;: {     // the content property of the payload in the step before   },   &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot; }   Note that the Request is currently in status Draft.                         Save the complete content of the response. You will need it in the next step.         Example response:  {   &quot;id&quot;: &quot;REQ...&quot;,   &quot;status&quot;: &quot;Draft&quot;,   // ...   &quot;content&quot;: {     &quot;@type&quot;: &quot;Request&quot;,     &quot;id&quot;: &quot;REQ...&quot;,     &quot;items&quot;: [       {         &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,         &quot;mustBeAccepted&quot;: true,         &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;       }     ]   } }   Send the Request  Now you have to send the Request to the Recipient. You can do so by calling the POST /api/v2/Messages route on the Sender Connector. Use the following JSON in the Request body:  {   &quot;recipients&quot;: [&quot;&lt;the address of the Recipient Connector&gt;&quot;],   &quot;content&quot;: {     // the content you copied in the step before   } }   This is where the automation of the enmeshed Runtime steps in and moves the Request from status Draft to status Open. You can observe this behaviour by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.  Fetch the Request  In order to fetch the Message with the Request, you have to synchronize the Recipient Connector (GET /api/v2/Account/Sync).  The enmeshed Runtime will read the Message and create a new incoming Request. You can observe this by long polling the incoming Requests or by waiting for the consumption.incomingRequestReceived event.  The long polling is done by calling the GET /api/v2/Requests/Incoming route. You can use the query params source.reference=&lt;id-of-the-message&gt; and status=ManualDecisionRequired to filter for Requests that belong to the Message that contained the Request.  For more information about the events you can head over to the Connector Modules site and read about the AMQP Publisher module and the Webhooks module that are propagating events.                         After you received the Request, save its id for the next step.         Answer the Request  Accept  If you want to accept the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Accept route. You can use the id you saved in the previous step. In the payload you have to accept at least all RequestItems where the mustBeAccepted property is set to true. In case of the example Request the payload is the following:  {   &quot;items&quot;: [     {       &quot;accept&quot;: true     }   ] }   Reject  If you want to reject the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Reject route. You can use the id you saved in the previous step. In the payload you have to reject all RequestItems. In case of the example Request the payload is the following:  {   &quot;items&quot;: [     {       &quot;accept&quot;: false     }   ] }   Runtime automation  No matter if you accepted or rejected the Request: the response is similar. You can see that the Request moved to status Decided. This is where the enmeshed Runtime steps in and handles the Request based on you decision. It will move the Request to status Completed and send the Response to the Sender via a Message. This behavior can be observed by querying the Request again after a few seconds (GET /api/v2/Requests/Incoming/{id}).  Sync the Response  The Sender will receive the Response as a Message. Therefore you have to synchronize the Sender Connector (GET /api/v2/Account/Sync).  After a few seconds the Request has moved to status Completed and the Response is available in the response property of the Request. You can observe this by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.">







  <meta property="article:published_time" content="2024-02-19T11:20:38+01:00">






<link rel="canonical" href="/integrate/requests-over-messages">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="enmeshed Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <link href="/assets/css/overwrite.css" rel="stylesheet" type="text/css" />

<!-- The following lines are needed because otherwise Prism (the syntax highlighter RapiDoc uses) breaks Rouge (the syntax highlighter we use) -->
<script>
    window.Prism = window.Prism || {};
    Prism.manual = true;
</script>
<script type="module" src="https://unpkg.com/rapidoc/dist/rapidoc-min.js"></script>



  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          enmeshed
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/use">Use</a>
            </li><li class="masthead__menu-item">
              <a href="/explore">Explore</a>
            </li><li class="masthead__menu-item">
              <a href="/integrate">Integrate</a>
            </li><li class="masthead__menu-item">
              <a href="/operate">Operate</a>
            </li><li class="masthead__menu-item">
              <a href="/contribute">Contribute</a>
            </li><li class="masthead__menu-item">
              <a href="/blog">Blog</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      <h3>Integrate enmeshed</h3>
      
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle Menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Getting Started</span>
        

        
        <ul>
          
            <li><a href="/integrate/access-the-connector">Access the Connector</a></li>
          
            <li><a href="/integrate/integration-example">Integration example</a></li>
          
            <li><a href="/integrate/event-introduction">Event introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Working with requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/request-and-response-introduction">Request and Response introduction</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage Requests</span>
        

        
        <ul>
          
            <li><a href="/integrate/requests-over-templates">Requests over Templates</a></li>
          
            <li><a href="/integrate/requests-over-messages" class="active">Requests over Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of yourself</span>
        

        
        <ul>
          
            <li><a href="/integrate/share-own-attribute-to-peer">Share own Attribute to peer</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Manage attributes of others</span>
        

        
        <ul>
          
            <li><a href="/integrate/read-attribute-from-peer">Read Attribute from peer</a></li>
          
            <li><a href="/integrate/create-attribute-for-peer">Create Attribute for peer</a></li>
          
            <li><a href="/integrate/propose-attribute-to-peer">Propose Attribute to peer</a></li>
          
            <li><a href="/integrate/request-persistent-consent-of-peer">Request persistent consent of peer</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Basic communication</span>
        

        
        <ul>
          
            <li><a href="/integrate/sending-messages">Sending Messages</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Requesting consent of users</span>
        

        
        <ul>
          
            <li><a href="/integrate/requesting-one-time-consents">Requesting one-time consents</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Data Model</span>
        

        
        <ul>
          
            <li><a href="/integrate/use-cases">Use Cases</a></li>
          
            <li><a href="/integrate/data-model-overview">Data Model Overview</a></li>
          
            <li><a href="/integrate/connector-events">Connector Events</a></li>
          
            <li><a href="/integrate/requests-and-requestitems">Requests and RequestItems</a></li>
          
            <li><a href="/integrate/attribute-values">Attribute Values</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Troubleshooting</span>
        

        
        <ul>
          
            <li><a href="/integrate/error-codes">Error Codes</a></li>
          
            <li><a href="/integrate/faq">FAQ</a></li>
          
            <li><a href="/integrate/support">Support</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
    
  
  </div>



  <article class="page h-entry" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Requests over Messages">
    <meta itemprop="description" content="This guide explains how to send and receive a Request over enmeshed Messages using two Connectors, the first of which sends a Request to the second, and the second accepts or rejects the Request. It provides step-by-step instructions for validating the Request, creating and sending the Request, and accepting or rejecting the Request.This guide assumes that you already have an active Relationship between two Connectors. If you don’t, you should follow the Requests over Templates guide first. If you created a Relationship during the Connector Tutorial this will also work.In this guide, the first Connector will be called Sender and the second Connector will be called Recipient. The Sender will send a Request to the Recipient. For the next steps you will need the enmeshed Address of the Recipient. You can find it out by calling the GET /api/v2/Relationships route on the Sender Connector.[  // ...  {    &quot;id&quot;: &quot;REL..&quot;,    &quot;status&quot;: &quot;Active&quot;,    // ...    &quot;peer&quot;: &quot;id1...&quot;  }]                    Look for the correct Relationship and then take its peer property. Save it for later.    Check your Requests validityAt first you should check if your Request is valid. You can do this by calling the POST /api/v2/Requests/Outgoing/Validate route on the Sender Connector with the following body.For simplicity the Request inside the Template only contains an AuthenticationRequestItem, but you can use any RequestItems you want.Even though the peer property is optional, it is recommended to specify it whenever possible. This allows additional validation rules to execute. When you are sending a Request over Messages you always know your peer.{  &quot;content&quot;: {    &quot;items&quot;: [      {        &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,        &quot;mustBeAccepted&quot;: true,        &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;      }    ]  },  &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot;}Create the RequestTo create the Request you have to call the POST /api/v2/Requests/Outgoing route on the Sender Connector. Use the following JSON in the Request body:{  &quot;content&quot;: {    // the content property of the payload in the step before  },  &quot;peer&quot;: &quot;&lt;the address of the Recipient Connector&gt;&quot;}Note that the Request is currently in status Draft.                    Save the complete content of the response. You will need it in the next step.    Example response:{  &quot;id&quot;: &quot;REQ...&quot;,  &quot;status&quot;: &quot;Draft&quot;,  // ...  &quot;content&quot;: {    &quot;@type&quot;: &quot;Request&quot;,    &quot;id&quot;: &quot;REQ...&quot;,    &quot;items&quot;: [      {        &quot;@type&quot;: &quot;AuthenticationRequestItem&quot;,        &quot;mustBeAccepted&quot;: true,        &quot;title&quot;: &quot;The Sender is asking for an authentication&quot;      }    ]  }}Send the RequestNow you have to send the Request to the Recipient. You can do so by calling the POST /api/v2/Messages route on the Sender Connector. Use the following JSON in the Request body:{  &quot;recipients&quot;: [&quot;&lt;the address of the Recipient Connector&gt;&quot;],  &quot;content&quot;: {    // the content you copied in the step before  }}This is where the automation of the enmeshed Runtime steps in and moves the Request from status Draft to status Open. You can observe this behaviour by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.Fetch the RequestIn order to fetch the Message with the Request, you have to synchronize the Recipient Connector (GET /api/v2/Account/Sync).The enmeshed Runtime will read the Message and create a new incoming Request. You can observe this by long polling the incoming Requests or by waiting for the consumption.incomingRequestReceived event.The long polling is done by calling the GET /api/v2/Requests/Incoming route. You can use the query params source.reference=&lt;id-of-the-message&gt; and status=ManualDecisionRequired to filter for Requests that belong to the Message that contained the Request.For more information about the events you can head over to the Connector Modules site and read about the AMQP Publisher module and the Webhooks module that are propagating events.                    After you received the Request, save its id for the next step.    Answer the RequestAcceptIf you want to accept the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Accept route. You can use the id you saved in the previous step. In the payload you have to accept at least all RequestItems where the mustBeAccepted property is set to true. In case of the example Request the payload is the following:{  &quot;items&quot;: [    {      &quot;accept&quot;: true    }  ]}RejectIf you want to reject the Request you can do so by calling the PUT /api/v2/Requests/Incoming/{id}/Reject route. You can use the id you saved in the previous step. In the payload you have to reject all RequestItems. In case of the example Request the payload is the following:{  &quot;items&quot;: [    {      &quot;accept&quot;: false    }  ]}Runtime automationNo matter if you accepted or rejected the Request: the response is similar. You can see that the Request moved to status Decided. This is where the enmeshed Runtime steps in and handles the Request based on you decision. It will move the Request to status Completed and send the Response to the Sender via a Message. This behavior can be observed by querying the Request again after a few seconds (GET /api/v2/Requests/Incoming/{id}).Sync the ResponseThe Sender will receive the Response as a Message. Therefore you have to synchronize the Sender Connector (GET /api/v2/Account/Sync).After a few seconds the Request has moved to status Completed and the Response is available in the response property of the Request. You can observe this by querying the Request via GET /api/v2/Requests/Outgoing/{id} on the Sender Connector.">
    <meta itemprop="datePublished" content="2024-02-19T11:20:38+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title p-name" itemprop="headline">
            <a href="/integrate/requests-over-messages" class="u-url" itemprop="url">Requests over Messages
</a>
          </h1>
          


        </header>
      

      <section class="page__content e-content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#check-your-requests-validity">Check your Requests validity</a></li><li><a href="#create-the-request">Create the Request</a></li><li><a href="#send-the-request">Send the Request</a></li><li><a href="#fetch-the-request">Fetch the Request</a></li><li><a href="#answer-the-request">Answer the Request</a><ul><li><a href="#accept">Accept</a></li><li><a href="#reject">Reject</a></li><li><a href="#runtime-automation">Runtime automation</a></li></ul></li><li><a href="#sync-the-response">Sync the Response</a></li></ul>

            </nav>
          </aside>
        
        <!-- A general description of the requirement can be given here. -->

<p>This guide explains how to send and receive a Request over enmeshed Messages using two Connectors, the first of which sends a Request to the second, and the second accepts or rejects the Request. It provides step-by-step instructions for validating the Request, creating and sending the Request, and accepting or rejecting the Request.</p>

<!-- This include inserts the table with the metadata  -->

<!--<div>
    <table>
        
        <tr><td>id</td>
            <td>SC060</td></tr>
        
        <tr><td>category</td>
            <td>Manage Requests</td></tr>
        
        <tr></tr>
        
        <tr><td>customer</td>
            <td>All</td></tr>
        
        <tr><td>component</td>
            <td>integrate</td></tr>
        
        <tr><td>level</td>
            <td>Beginner</td></tr>
        
        <tr><td>implementation status</td>
            <td>DONE</td></tr>
        
        <tr><td>documentation status</td>
            <td>OLD</td></tr>
        
        <tr><td>published</td>
            <td>true</td></tr>
        
        <tr><td>link</td>
            <td>integrate/requests-over-messages</td></tr>
        
        <tr><td colspan="2">
                <details>
                    <summary>requires</summary>
                        
                    <p><a href="../integrate/requests-over-templates">  Requests over Templates  </a></p>
                    
                </details>
            </td></tr>
        <tr><td colspan="2">
                <details>
                    <summary>required by</summary>
                        
                    <p><a href="../integrate/requesting-one-time-consents">  Requesting one-time consents   </a></p>
                        
                    <p><a href="../integrate/request-persistent-consent-of-peer">  Request persistent consent of peer   </a></p>
                        
                    <p><a href="../integrate/requesting-authentication">  Requesting authentication   </a></p>
                    
                </details>
            </td></tr>
    </table>
</div>
-->

<p>This guide assumes that you already have an active Relationship between two Connectors. If you don’t, you should follow the <a href="/integrate/requests-over-templates">Requests over Templates</a> guide first. If you created a Relationship during the <a href="/integrate/integration-example">Connector Tutorial</a> this will also work.</p>

<p>In this guide, the first Connector will be called Sender and the second Connector will be called Recipient. The Sender will send a Request to the Recipient. For the next steps you will need the enmeshed Address of the Recipient. You can find it out by calling the <code class="language-plaintext highlighter-rouge">GET /api/v2/Relationships</code> route on the Sender Connector.</p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
  </span><span class="c1">// ...</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"REL.."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Active"</span><span class="p">,</span><span class="w">
    </span><span class="c1">// ...</span><span class="w">
    </span><span class="nl">"peer"</span><span class="p">:</span><span class="w"> </span><span class="s2">"id1..."</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<table style="border: none" class="notice--warning">
    <tr>
        <td style="border: none"><i style="font-size: 2em" class="fas fa-fw fa-copy" /></td>
        <td style="border: none"><p>Look for the correct Relationship and then take its <code class="language-plaintext highlighter-rouge">peer</code> property. Save it for later.</p>
</td>
    </tr>
</table>

<h2 id="check-your-requests-validity">Check your Requests validity</h2>

<p>At first you should check if your Request is valid. You can do this by calling the <code class="language-plaintext highlighter-rouge">POST /api/v2/Requests/Outgoing/Validate</code> route on the Sender Connector with the following body.
For simplicity the Request inside the Template only contains an AuthenticationRequestItem, but you can use any <a href="/integrate/data-model-overview#requestitems">RequestItems</a> you want.</p>

<p>Even though the <code class="language-plaintext highlighter-rouge">peer</code> property is optional, it is recommended to specify it whenever possible. This allows additional validation rules to execute. When you are sending a Request over Messages you always know your peer.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"items"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
        </span><span class="nl">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AuthenticationRequestItem"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"mustBeAccepted"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"The Sender is asking for an authentication"</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"peer"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;the address of the Recipient Connector&gt;"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="create-the-request">Create the Request</h2>

<p>To create the Request you have to call the <code class="language-plaintext highlighter-rouge">POST /api/v2/Requests/Outgoing</code> route on the Sender Connector. Use the following JSON in the Request body:</p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c1">// the content property of the payload in the step before</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"peer"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;the address of the Recipient Connector&gt;"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Note that the Request is currently in status <code class="language-plaintext highlighter-rouge">Draft</code>.</p>

<table style="border: none" class="notice--warning">
    <tr>
        <td style="border: none"><i style="font-size: 2em" class="fas fa-fw fa-copy" /></td>
        <td style="border: none"><p>Save the complete <code class="language-plaintext highlighter-rouge">content</code> of the response. You will need it in the next step.</p>
</td>
    </tr>
</table>

<p><strong>Example response:</strong></p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"REQ..."</span><span class="p">,</span><span class="w">
  </span><span class="nl">"status"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Draft"</span><span class="p">,</span><span class="w">
  </span><span class="c1">// ...</span><span class="w">
  </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Request"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"REQ..."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"items"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
        </span><span class="nl">"@type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AuthenticationRequestItem"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"mustBeAccepted"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
        </span><span class="nl">"title"</span><span class="p">:</span><span class="w"> </span><span class="s2">"The Sender is asking for an authentication"</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="send-the-request">Send the Request</h2>

<p>Now you have to send the Request to the Recipient. You can do so by calling the <code class="language-plaintext highlighter-rouge">POST /api/v2/Messages</code> route on the Sender Connector. Use the following JSON in the Request body:</p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"recipients"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"&lt;the address of the Recipient Connector&gt;"</span><span class="p">],</span><span class="w">
  </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c1">// the content you copied in the step before</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This is where the automation of the enmeshed Runtime steps in and moves the Request from status <code class="language-plaintext highlighter-rouge">Draft</code> to status <code class="language-plaintext highlighter-rouge">Open</code>. You can observe this behaviour by querying the Request via <code class="language-plaintext highlighter-rouge">GET /api/v2/Requests/Outgoing/{id}</code> on the Sender Connector.</p>

<h2 id="fetch-the-request">Fetch the Request</h2>

<p>In order to fetch the Message with the Request, you have to synchronize the Recipient Connector (<code class="language-plaintext highlighter-rouge">GET /api/v2/Account/Sync</code>).</p>

<p>The enmeshed Runtime will read the Message and create a new incoming Request. You can observe this by long polling the incoming Requests or by waiting for the <code class="language-plaintext highlighter-rouge">consumption.incomingRequestReceived</code> event.</p>

<p>The long polling is done by calling the <code class="language-plaintext highlighter-rouge">GET /api/v2/Requests/Incoming</code> route. You can use the query params <code class="language-plaintext highlighter-rouge">source.reference=&lt;id-of-the-message&gt;</code> and <code class="language-plaintext highlighter-rouge">status=ManualDecisionRequired</code> to filter for Requests that belong to the Message that contained the Request.</p>

<p>For more information about the events you can head over to the <a href="/operate/modules">Connector Modules site</a> and read about the <a href="/operate/modules#amqppublisher">AMQP Publisher module</a> and the <a href="/operate/modules#webhooks">Webhooks module</a> that are propagating events.</p>

<table style="border: none" class="notice--warning">
    <tr>
        <td style="border: none"><i style="font-size: 2em" class="fas fa-fw fa-copy" /></td>
        <td style="border: none"><p>After you received the Request, save its <code class="language-plaintext highlighter-rouge">id</code> for the next step.</p>
</td>
    </tr>
</table>

<h2 id="answer-the-request">Answer the Request</h2>

<h3 id="accept">Accept</h3>

<p>If you want to accept the Request you can do so by calling the <code class="language-plaintext highlighter-rouge">PUT /api/v2/Requests/Incoming/{id}/Accept</code> route. You can use the <code class="language-plaintext highlighter-rouge">id</code> you saved in the previous step. In the payload you have to accept at least all RequestItems where the <code class="language-plaintext highlighter-rouge">mustBeAccepted</code> property is set to <code class="language-plaintext highlighter-rouge">true</code>. In case of the example Request the payload is the following:</p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"items"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"accept"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="reject">Reject</h3>

<p>If you want to reject the Request you can do so by calling the <code class="language-plaintext highlighter-rouge">PUT /api/v2/Requests/Incoming/{id}/Reject</code> route. You can use the <code class="language-plaintext highlighter-rouge">id</code> you saved in the previous step. In the payload you have to reject all RequestItems. In case of the example Request the payload is the following:</p>

<div class="language-jsonc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"items"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"accept"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="runtime-automation">Runtime automation</h3>

<p>No matter if you accepted or rejected the Request: the response is similar. You can see that the Request moved to status <code class="language-plaintext highlighter-rouge">Decided</code>. This is where the enmeshed Runtime steps in and handles the Request based on you decision. It will move the Request to status <code class="language-plaintext highlighter-rouge">Completed</code> and send the Response to the Sender via a Message. This behavior can be observed by querying the Request again after a few seconds (<code class="language-plaintext highlighter-rouge">GET /api/v2/Requests/Incoming/{id}</code>).</p>

<h2 id="sync-the-response">Sync the Response</h2>

<p>The Sender will receive the Response as a Message. Therefore you have to synchronize the Sender Connector (<code class="language-plaintext highlighter-rouge">GET /api/v2/Account/Sync</code>).</p>

<p>After a few seconds the Request has moved to status <code class="language-plaintext highlighter-rouge">Completed</code> and the Response is available in the <code class="language-plaintext highlighter-rouge">response</code> property of the Request. You can observe this by querying the Request via <code class="language-plaintext highlighter-rouge">GET /api/v2/Requests/Outgoing/{id}</code> on the Sender Connector.</p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2024-02-19T11:20:38+01:00">February 19, 2024</time></p>

      </footer>

      

      
    </div>

    
  </article>

  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
    <ul class="social-icons">
           
        <li>
            <a href="/legal" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-info" aria-hidden="true"></i> Legal Disclosure</a>
        </li>
          
        <li>
            <a href="/privacy" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-user-shield" aria-hidden="true"></i> Privacy Statement</a>
        </li>
          
        <li>
            <a href="https://www.enmeshed.eu" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> Website</a>
        </li>
          
        <li>
            <a href="https://github.com/nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a>
        </li>
          
        <li>
            <a href="https://www.npmjs.com/search?q=%40nmshd" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-npm" aria-hidden="true"></i> NPM</a>
        </li>
           
        <li>
            <a href="/feed.xml"
                ><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a
            >
        </li>
        
    </ul>
</div>

<div class="page__footer-copyright">
    &copy; 2024
    <a href="https://www.js-soft.com">j&amp;s-soft GmbH</a>. Powered by
    <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.
</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
