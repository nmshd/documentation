import * as fs from "fs";
import path from "path";
const Excel = require("exceljs");
const filePath = path.normalize(__dirname + "/UseCases.xlsx");
const scenarioWorksheetName = "Scenarios";
const useCasesWorksheetName = "UseCases";

// Define the interface dynamically based on the headers
interface DynamicUseCase {
    [key: string]: any;
}
// Asynchrone Funktion zum Lesen der Datei
function dateiLesenUndAusgeben(object: DynamicUseCase): void {
    fs.readFile("_docs_" + object.Link + ".md", "utf8", (err, daten) => {
        if (err) {
            console.error("Fehler beim Lesen der Datei:", err);
            return;
        }

        // Dateiinhalt in der Konsole ausgeben

        var text = "---\n";
        text += "# !!! Warning: Do not edit this file; any changes must be replicated in Excel !!!\n";
        text += "permalink: " + object.Link + "\n";
        if ((object["Documentation Status"] == "DONE" || object["Documentation Status"] == "OLD") && object.redirect_from !== null) {
            text += "redirect_from:\n";
            for (const link of object.redirect_from.split(" ")) {
                text += `  - ${link}\n`;
            }
        }

        if (object["Documentation Status"] == "DONE" || object["Documentation Status"] == "OLD") {
            text += "published: true\n";
        } else {
            text += "published: false\n";
        }
        text += 'title: "' + replaceEach(object.Title, ["<", "", ">", "", ":", "", "â€™", "'"]) + '"\n';
        text += "type: scenario\n";
        text += "toc: true\n";
        text += "properties:\n";

        for (const key in object) {
            if (
                key != "Product" &&
                key != "Role" &&
                key != "Title" &&
                key != "User Story" &&
                key != "New Component" &&
                key != "Require" &&
                key != "NBP_Scenario" &&
                key != "Link to Jira" &&
                key != "redirect_from"
            )
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    const value = object[key];

                    if (value == null) {
                        text += "  - " + `${key.toLowerCase()}:\n`;
                    } else {
                        text += "  - " + `${key.toLowerCase()}: ${value}\n`;
                    }
                }
        }

        text += "require:\n";
        text += "required_by:\n";
        text += "---";

        const regex = /---[\s\S]*?---/g; // Regular expression to match text between "---" across multiple lines
        var strippedText = daten.replace(regex, text); // Replace matched text with an empty string
        fs.writeFileSync("_docs_" + object.Link + ".md", strippedText, "utf-8");
    });
}

async function readExcelFile(filePath: string, worksheetName: string): Promise<DynamicUseCase[]> {
    var workbook = new Excel.Workbook();
    try {
        await workbook.xlsx.readFile(filePath);

        var worksheet = workbook.getWorksheet(worksheetName);

        // Check if the worksheet exists
        if (!worksheet) {
            const worksheetNames = workbook.worksheets.map((worksheet: { name: any }) => worksheet.name);
            throw new Error("Worksheet '" + worksheetName + "' not found. Possible entries are: " + worksheetNames);
        }

        // Get the headers from the first row of the Excel file
        const headers: string[] = [];
        worksheet.getRow(1).eachCell({ includeEmpty: false }, (cell: { value: string }) => {
            headers.push(cell.value as string);
        });
        var dynamicUseCases: DynamicUseCase[] = [];

        // Iterate over each row (skipping the first row as it contains headers)
        for (let rowNumber = 2; rowNumber <= worksheet.rowCount; rowNumber++) {
            const currentRow = worksheet.getRow(rowNumber);

            // Create a DynamicUseCase object for the current row
            const dynamicUseCase: DynamicUseCase = {};
            headers.forEach((header, index) => {
                // if the result is a formula, only the result is used
                if (typeof currentRow.getCell(index + 1).value === "object" && currentRow.getCell(index + 1).value !== null) {
                    dynamicUseCase[header] = currentRow.getCell(index + 1).value.result;
                } else {
                    dynamicUseCase[header] = currentRow.getCell(index + 1).value;
                }
            });
            // Add the DynamicUseCase object to the array
            dynamicUseCases.push(dynamicUseCase);
        }

        // Now 'dynamicUseCases' is an array containing objects for each row in the Excel table

        return dynamicUseCases;
    } catch (error: any) {
        // This block will catch any errors thrown in the try block or by the Promise
        console.error("Async operation failed:", error.message);
        // Propagate the error or handle it as needed
        throw error;
    }
}

function replaceEach(str: string, replacements: string[]): string {
    let result = str;
    for (let i = 0; i < replacements.length; i += 2) {
        result = result.replace(new RegExp(replacements[i], "g"), replacements[i + 1]);
    }
    return result;
}

// Funktion aufrufen
// dateiLesenUndAusgeben(normalisedPath);
// Call the function and handle the returned promise
// const dynamicUseCases: DynamicUseCase[] = readExcelFile(filePath, scenarioWorksheetName).then((result) => {
//     if (result !== null) {
//         console.log("Dynamic Use Cases List:", result);
//         return result;
//     } else {
//         console.log("Error reading Excel file. Result is null.");
//     }
// });

// readExcelFile(filePath, useCasesWorksheetName).then((result) => {
//     if (result !== null) {
//         console.log("Dynamic Use Cases List:", result);
//     } else {
//         console.log("Error reading Excel file. Result is null.");
//     }
// });
// console.log(scenarios);

// dateiLesenUndAusgeben(dynamicUseCases[1].link);
async function main() {
    try {
        const dynamicUseCases = await readExcelFile(filePath, scenarioWorksheetName);

        // Check if the array is not empty before accessing the first element
        if (dynamicUseCases && dynamicUseCases.length > 0) {
            dynamicUseCases.forEach((element) => {
                dateiLesenUndAusgeben(element);
            });
        } else {
            console.log("The array is empty or undefined.");
        }
    } catch (error) {
        console.error("Error:", error);
    }
}

main();
